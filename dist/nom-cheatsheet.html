<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nom Cheatsheet</title>
    <style>
/* Downloaded from https://raw.githubusercontent.com/sindresorhus/github-markdown-css/gh-pages/github-markdown.css */
@media (prefers-color-scheme: dark) {
  .markdown-body {
    color-scheme: dark;
    --color-prettylights-syntax-comment: #8b949e;
    --color-prettylights-syntax-constant: #79c0ff;
    --color-prettylights-syntax-entity: #d2a8ff;
    --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
    --color-prettylights-syntax-entity-tag: #7ee787;
    --color-prettylights-syntax-keyword: #ff7b72;
    --color-prettylights-syntax-string: #a5d6ff;
    --color-prettylights-syntax-variable: #ffa657;
    --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
    --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
    --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
    --color-prettylights-syntax-carriage-return-text: #f0f6fc;
    --color-prettylights-syntax-carriage-return-bg: #b62324;
    --color-prettylights-syntax-string-regexp: #7ee787;
    --color-prettylights-syntax-markup-list: #f2cc60;
    --color-prettylights-syntax-markup-heading: #1f6feb;
    --color-prettylights-syntax-markup-italic: #c9d1d9;
    --color-prettylights-syntax-markup-bold: #c9d1d9;
    --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
    --color-prettylights-syntax-markup-deleted-bg: #67060c;
    --color-prettylights-syntax-markup-inserted-text: #aff5b4;
    --color-prettylights-syntax-markup-inserted-bg: #033a16;
    --color-prettylights-syntax-markup-changed-text: #ffdfb6;
    --color-prettylights-syntax-markup-changed-bg: #5a1e02;
    --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
    --color-prettylights-syntax-markup-ignored-bg: #1158c7;
    --color-prettylights-syntax-meta-diff-range: #d2a8ff;
    --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
    --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
    --color-fg-default: #c9d1d9;
    --color-fg-muted: #8b949e;
    --color-fg-subtle: #484f58;
    --color-canvas-default: #0d1117;
    --color-canvas-subtle: #161b22;
    --color-border-default: #30363d;
    --color-border-muted: #21262d;
    --color-neutral-muted: rgba(110,118,129,0.4);
    --color-accent-fg: #58a6ff;
    --color-accent-emphasis: #1f6feb;
    --color-attention-subtle: rgba(187,128,9,0.15);
    --color-danger-fg: #f85149;
  }
}

@media (prefers-color-scheme: light) {
  .markdown-body {
    color-scheme: light;
    --color-prettylights-syntax-comment: #6e7781;
    --color-prettylights-syntax-constant: #0550ae;
    --color-prettylights-syntax-entity: #8250df;
    --color-prettylights-syntax-storage-modifier-import: #24292f;
    --color-prettylights-syntax-entity-tag: #116329;
    --color-prettylights-syntax-keyword: #cf222e;
    --color-prettylights-syntax-string: #0a3069;
    --color-prettylights-syntax-variable: #953800;
    --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
    --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
    --color-prettylights-syntax-invalid-illegal-bg: #82071e;
    --color-prettylights-syntax-carriage-return-text: #f6f8fa;
    --color-prettylights-syntax-carriage-return-bg: #cf222e;
    --color-prettylights-syntax-string-regexp: #116329;
    --color-prettylights-syntax-markup-list: #3b2300;
    --color-prettylights-syntax-markup-heading: #0550ae;
    --color-prettylights-syntax-markup-italic: #24292f;
    --color-prettylights-syntax-markup-bold: #24292f;
    --color-prettylights-syntax-markup-deleted-text: #82071e;
    --color-prettylights-syntax-markup-deleted-bg: #FFEBE9;
    --color-prettylights-syntax-markup-inserted-text: #116329;
    --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
    --color-prettylights-syntax-markup-changed-text: #953800;
    --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
    --color-prettylights-syntax-markup-ignored-text: #eaeef2;
    --color-prettylights-syntax-markup-ignored-bg: #0550ae;
    --color-prettylights-syntax-meta-diff-range: #8250df;
    --color-prettylights-syntax-brackethighlighter-angle: #57606a;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
    --color-prettylights-syntax-constant-other-reference-link: #0a3069;
    --color-fg-default: #24292f;
    --color-fg-muted: #57606a;
    --color-fg-subtle: #6e7781;
    --color-canvas-default: #ffffff;
    --color-canvas-subtle: #f6f8fa;
    --color-border-default: #d0d7de;
    --color-border-muted: hsla(210,18%,87%,1);
    --color-neutral-muted: rgba(175,184,193,0.2);
    --color-accent-fg: #0969da;
    --color-accent-emphasis: #0969da;
    --color-attention-subtle: #fff8c5;
    --color-danger-fg: #cf222e;
  }
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--color-fg-default);
  background-color: var(--color-canvas-default);
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body h1:hover .anchor .octicon-link:before,
.markdown-body h2:hover .anchor .octicon-link:before,
.markdown-body h3:hover .anchor .octicon-link:before,
.markdown-body h4:hover .anchor .octicon-link:before,
.markdown-body h5:hover .anchor .octicon-link:before,
.markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.markdown-body details,
.markdown-body figcaption,
.markdown-body figure {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body [hidden] {
  display: none !important;
}

.markdown-body a {
  background-color: transparent;
  color: var(--color-accent-fg);
  text-decoration: none;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.markdown-body b,
.markdown-body strong {
  font-weight: 600;
}

.markdown-body dfn {
  font-style: italic;
}

.markdown-body h1 {
  margin: .67em 0;
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body mark {
  background-color: var(--color-attention-subtle);
  color: var(--color-text-primary);
}

.markdown-body small {
  font-size: 90%;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body sup {
  top: -0.5em;
}

.markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--color-canvas-default);
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body figure {
  margin: 1em 40px;
}

.markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--color-border-muted);
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--color-border-default);
  border: 0;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body [type=button],
.markdown-body [type=reset],
.markdown-body [type=submit] {
  -webkit-appearance: button;
}

.markdown-body [type=button]::-moz-focus-inner,
.markdown-body [type=reset]::-moz-focus-inner,
.markdown-body [type=submit]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

.markdown-body [type=button]:-moz-focusring,
.markdown-body [type=reset]:-moz-focusring,
.markdown-body [type=submit]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

.markdown-body [type=checkbox],
.markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body [type=number]::-webkit-inner-spin-button,
.markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.markdown-body [type=search] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

.markdown-body [type=search]::-webkit-search-cancel-button,
.markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--color-fg-default);
  vertical-align: middle;
  background-color: var(--color-canvas-subtle);
  border: solid 1px var(--color-neutral-muted);
  border-bottom-color: var(--color-neutral-muted);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--color-neutral-muted);
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h2 {
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body h3 {
  font-weight: 600;
  font-size: 1.25em;
}

.markdown-body h4 {
  font-weight: 600;
  font-size: 1em;
}

.markdown-body h5 {
  font-weight: 600;
  font-size: .875em;
}

.markdown-body h6 {
  font-weight: 600;
  font-size: .85em;
  color: var(--color-fg-muted);
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--color-fg-muted);
  border-left: .25em solid var(--color-border-default);
}

.markdown-body ul,
.markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body tt,
.markdown-body code {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-body ::placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.markdown-body input::-webkit-outer-spin-button,
.markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.markdown-body [data-catalyst] {
  display: block;
}

.markdown-body g-emoji {
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: 400;
  line-height: 1;
  vertical-align: -0.075em;
}

.markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .absent {
  color: var(--color-danger-fg);
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body sup>a::before {
  content: "[";
}

.markdown-body sup>a::after {
  content: "]";
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: var(--color-fg-default);
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.markdown-body ol[type=a] {
  list-style-type: lower-alpha;
}

.markdown-body ol[type=i] {
  list-style-type: lower-roman;
}

.markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--color-border-default);
}

.markdown-body table tr {
  background-color: var(--color-canvas-default);
  border-top: 1px solid var(--color-border-muted);
}

.markdown-body table tr:nth-child(2n) {
  background-color: var(--color-canvas-subtle);
}

.markdown-body table img {
  background-color: transparent;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--color-border-default);
}

.markdown-body span.frame span img {
  display: block;
  float: left;
}

.markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--color-fg-default);
}

.markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.markdown-body span.float-left span {
  margin: 13px 0 0;
}

.markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body code,
.markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  background-color: var(--color-neutral-muted);
  border-radius: 6px;
}

.markdown-body code br,
.markdown-body tt br {
  display: none;
}

.markdown-body del code {
  text-decoration: inherit;
}

.markdown-body pre code {
  font-size: 100%;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: var(--color-canvas-subtle);
  border-radius: 6px;
}

.markdown-body pre code,
.markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .csv-data td,
.markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--color-canvas-default);
  border: 0;
}

.markdown-body .csv-data tr {
  border-top: 0;
}

.markdown-body .csv-data th {
  font-weight: 600;
  background: var(--color-canvas-subtle);
  border-top: 0;
}

.markdown-body .footnotes {
  font-size: 12px;
  color: var(--color-fg-muted);
  border-top: 1px solid var(--color-border-default);
}

.markdown-body .footnotes ol {
  padding-left: 16px;
}

.markdown-body .footnotes li {
  position: relative;
}

.markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--color-accent-emphasis);
  border-radius: 6px;
}

.markdown-body .footnotes li:target {
  color: var(--color-fg-default);
}

.markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item label {
  font-weight: 400;
}

.markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item .handle {
  display: none;
}

.markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
@media (prefers-color-scheme: dark) {/*
 * theme "Solarized (dark)" generated by syntect
 */

.code {
 color: #839496;
 background-color: #002b36;
}

.comment, .meta.documentation {
 color: #586e75;
}
.string {
 color: #2aa198;
}
.string.regexp {
 color: #2aa198;
}
.constant.character.escape {
 color: #dc322f;
}
.constant.numeric {
 color: #6c71c4;
}
.variable {
 color: #268bd2;
}
.variable.function {
 color: #b58900;
}
.variable.language {
 color: #d33682;
}
.keyword {
 color: #859900;
}
.meta.import .keyword, .keyword.control.import, .keyword.control.import.from, .keyword.other.import, .keyword.control.at-rule.include, .keyword.control.at-rule.import {
 color: #cb4b16;
}
.keyword.operator.comparison, .keyword.operator.assignment, .keyword.operator.arithmetic {
 color: #657b83;
}
.storage {
 color: #859900;
}
.storage.modifier {
 color: #93a1a1;
}
.keyword.control.class, .entity.name, .entity.name.class, .entity.name.type.class {
 color: #b58900;
}
.entity.other.inherited-class {
 color: #268bd2;
}
.entity.other.attribute-name {
 color: #b58900;
}
.support, .support.type, .support.class {
 color: #859900;
}
.entity.name.function {
 color: #b58900;
}
.punctuation.definition.variable {
 color: #859900;
}
.constant, .constant.language, .meta.preprocessor {
 color: #b58900;
}
.entity.name.section {
 color: #cb4b16;
}
.support.function.construct, .keyword.other.new {
 color: #dc322f;
}
.constant.character, .constant.other {
 color: #cb4b16;
}
.entity.name.tag {
 color: #268bd2;
}
.punctuation.definition.tag.html, .punctuation.definition.tag.begin, .punctuation.definition.tag.end {
 color: #586e75;
}
.support.function {
 color: #859900;
}
.punctuation.separator.continuation {
 color: #dc322f;
}
.storage.type {
 color: #268bd2;
}
.support.type.exception {
 color: #cb4b16;
}
.keyword.other.special-method {
 color: #cb4b16;
}
.invalid {
 background-color: #6e2e32;
}
.string.quoted.double, .string.quoted.single {
 color: #2aa198;
}
.punctuation.definition.string {
 color: #839496;
}
.meta.brace.square, .punctuation.section.brackets {
 color: #268bd2;
}
.meta.brace.round, .meta.brace.curly, .punctuation.section, .punctuation.section.block, .punctuation.definition.parameters, .punctuation.section.group {
 color: #657b83;
}
.support.constant.color, .invalid.deprecated.color.w3c-non-standard-color-name.scss {
 color: #b58900;
}
.meta.selector.css {
 color: #657b83;
}
.entity.name.tag.css, .entity.name.tag.scss, .source.less .keyword.control.html.elements, .source.sass .keyword.control.untitled {
 color: #b58900;
}
.entity.other.attribute-name.class {
 color: #b58900;
}
.entity.other.attribute-name.id {
 color: #b58900;
}
.entity.other.attribute-name.pseudo-element, .entity.other.attribute-name.tag.pseudo-element, .entity.other.attribute-name.pseudo-class, .entity.other.attribute-name.tag.pseudo-class {
 color: #268bd2;
}
.text.html.basic .meta.tag.other.html, .text.html.basic .meta.tag.any.html, .text.html.basic .meta.tag.block.any, .text.html.basic .meta.tag.inline.any, .text.html.basic .meta.tag.structure.any.html, .text.html.basic .source.js.embedded.html, .punctuation.separator.key-value.html {
 color: #657b83;
}
.text.html.basic .entity.other.attribute-name.html, .meta.tag.xml .entity.other.attribute-name {
 color: #b58900;
}
.keyword.other.special-method.ruby {
 color: #859900;
}
.variable.other.constant.ruby {
 color: #b58900;
}
.constant.other.symbol.ruby {
 color: #2aa198;
}
.keyword.other.special-method.ruby {
 color: #cb4b16;
}
.meta.array .support.function.construct.php {
 color: #b58900;
}
.entity.name.function.preprocessor.c, .meta.preprocessor.c.include, .meta.preprocessor.macro.c {
 color: #cb4b16;
}
.meta.preprocessor.c.include .string.quoted.other.lt-gt.include.c, .meta.preprocessor.c.include .punctuation.definition.string.begin.c, .meta.preprocessor.c.include .punctuation.definition.string.end.c {
 color: #2aa198;
}
.other.package.exclude, .other.remove {
 color: #dc322f;
}
.other.add {
 color: #2aa198;
}
.punctuation.section.group.tex, .punctuation.definition.arguments.begin.latex, .punctuation.definition.arguments.end.latex, .punctuation.definition.arguments.latex {
 color: #dc322f;
}
.meta.group.braces.tex {
 color: #b58900;
}
.string.other.math.tex {
 color: #b58900;
}
.variable.parameter.function.latex {
 color: #cb4b16;
}
.punctuation.definition.constant.math.tex {
 color: #dc322f;
}
.text.tex.latex .constant.other.math.tex, .constant.other.general.math.tex, .constant.other.general.math.tex, .constant.character.math.tex {
 color: #2aa198;
}
.string.other.math.tex {
 color: #b58900;
}
.punctuation.definition.string.begin.tex, .punctuation.definition.string.end.tex {
 color: #dc322f;
}
.keyword.control.label.latex, .text.tex.latex .constant.other.general.math.tex {
 color: #2aa198;
}
.variable.parameter.definition.label.latex {
 color: #dc322f;
}
.support.function.be.latex {
 color: #859900;
}
.support.function.section.latex {
 color: #cb4b16;
}
.support.function.general.tex {
 color: #2aa198;
}
.keyword.control.ref.latex {
 color: #2aa198;
}
.storage.type.class.python, .storage.type.function.python, .storage.modifier.global.python {
 color: #859900;
}
.support.type.exception.python {
 color: #b58900;
}
.meta.scope.for-in-loop.shell, .variable.other.loop.shell {
 color: #93a1a1;
}
.meta.scope.case-block.shell, .meta.scope.case-body.shell {
 color: #93a1a1;
}
.punctuation.definition.logical-expression.shell {
 color: #dc322f;
}
.storage.modifier.c++ {
 color: #859900;
}
.support.function.perl {
 color: #268bd2;
}
.meta.diff, .meta.diff.header {
 color: #586e75;
}
.meta.diff.range {
 color: #268bd2;
}
.markup.deleted {
 color: #dc322f;
}
.markup.changed {
 color: #2aa198;
}
.markup.inserted {
 color: #859900;
}
.markup.heading, .punctuation.definition.heading.markdown {
 color: #b58900;
}
.markup.quote {
 color: #859900;
}
.markup.italic {
font-style: italic;
}
.markup.bold {
font-weight: bold;
}
.markup.underline.link.markdown, .meta.link.reference .constant.other.reference.link.markdown {
 color: #2aa198;
}
.constant.other.reference.link.markdown {
 color: #6c71c4;
}
.meta.paragraph.markdown .meta.dummy.line-break {
 background-color: #586e75;
}
.sublimelinter.notes {
 color: #586e75;
 background-color: #586e75;
}
.sublimelinter.outline.illegal {
 color: #586e75;
 background-color: #586e75;
}
.sublimelinter.underline.illegal {
 background-color: #dc322f;
}
.sublimelinter.outline.warning {
 color: #839496;
 background-color: #839496;
}
.sublimelinter.underline.warning {
 background-color: #b58900;
}
.sublimelinter.outline.violation {
 color: #657b83;
 background-color: #657b83;
}
.sublimelinter.underline.violation {
 background-color: #cb4b16;
}
.sublimelinter.mark.warning {
 color: #b58900;
}
.sublimelinter.mark.error {
 color: #dc322f;
}
.sublimelinter.gutter-mark {
 color: #657b83;
}
.brackethighlighter.all {
 color: #586e75;
}
.entity.name.filename.find-in-files {
 color: #2aa198;
}
.constant.numeric.line-number.find-in-files {
 color: #586e75;
}
.markup.deleted.git_gutter {
 color: #dc322f;
}
.markup.inserted.git_gutter {
 color: #859900;
}
.markup.changed.git_gutter {
 color: #b58900;
}
.variable.other.readwrite.js, .variable.other.object.js, .variable.other.constant.js {
 color: #839496;
}
}
@media (prefers-color-scheme: light) {/*
 * theme "Solarized (light)" generated by syntect
 */

.code {
 color: #657b83;
 background-color: #fdf6e3;
}

.comment, .meta.documentation {
 color: #93a1a1;
}
.string {
 color: #2aa198;
}
.string.regexp {
 color: #2aa198;
}
.constant.character.escape {
 color: #dc322f;
}
.constant.numeric {
 color: #6c71c4;
}
.variable {
 color: #268bd2;
}
.variable.function {
 color: #b58900;
}
.variable.language {
 color: #d33682;
}
.keyword {
 color: #859900;
}
.meta.import .keyword, .keyword.control.import, .keyword.control.import.from, .keyword.other.import, .keyword.control.at-rule.include, .keyword.control.at-rule.import {
 color: #cb4b16;
}
.keyword.operator.comparison, .keyword.operator.assignment, .keyword.operator.arithmetic {
 color: #657b83;
}
.storage {
 color: #859900;
}
.storage.modifier {
 color: #586e75;
}
.keyword.control.class, .entity.name, .entity.name.class, .entity.name.type.class {
 color: #b58900;
}
.entity.other.inherited-class {
 color: #268bd2;
}
.entity.other.attribute-name {
 color: #b58900;
}
.support, .support.type, .support.class {
 color: #859900;
}
.entity.name.function {
 color: #b58900;
}
.punctuation.definition.variable {
 color: #859900;
}
.constant, .constant.language, .meta.preprocessor {
 color: #b58900;
}
.entity.name.section {
 color: #cb4b16;
}
.support.function.construct, .keyword.other.new {
 color: #dc322f;
}
.constant.character, .constant.other {
 color: #cb4b16;
}
.entity.name.tag {
 color: #268bd2;
}
.punctuation.definition.tag.html, .punctuation.definition.tag.begin, .punctuation.definition.tag.end {
 color: #93a1a1;
}
.support.function {
 color: #859900;
}
.punctuation.separator.continuation {
 color: #dc322f;
}
.storage.type {
 color: #268bd2;
}
.support.type.exception {
 color: #cb4b16;
}
.keyword.other.special-method {
 color: #cb4b16;
}
.invalid {
 background-color: #ec9489;
}
.string.quoted.double, .string.quoted.single {
 color: #2aa198;
}
.punctuation.definition.string {
 color: #839496;
}
.meta.brace.square, .punctuation.section.brackets {
 color: #268bd2;
}
.meta.brace.round, .meta.brace.curly, .punctuation.section, .punctuation.section.block, .punctuation.definition.parameters, .punctuation.section.group {
 color: #657b83;
}
.support.constant.color, .invalid.deprecated.color.w3c-non-standard-color-name.scss {
 color: #b58900;
}
.meta.selector.css {
 color: #657b83;
}
.entity.name.tag.css, .entity.name.tag.scss, .source.less .keyword.control.html.elements, .source.sass .keyword.control.untitled {
 color: #b58900;
}
.entity.other.attribute-name.class {
 color: #b58900;
}
.entity.other.attribute-name.id {
 color: #b58900;
}
.entity.other.attribute-name.pseudo-element, .entity.other.attribute-name.tag.pseudo-element, .entity.other.attribute-name.pseudo-class, .entity.other.attribute-name.tag.pseudo-class {
 color: #268bd2;
}
.text.html.basic .meta.tag.other.html, .text.html.basic .meta.tag.any.html, .text.html.basic .meta.tag.block.any, .text.html.basic .meta.tag.inline.any, .text.html.basic .meta.tag.structure.any.html, .text.html.basic .source.js.embedded.html, .punctuation.separator.key-value.html {
 color: #657b83;
}
.text.html.basic .entity.other.attribute-name.html, .meta.tag.xml .entity.other.attribute-name {
 color: #b58900;
}
.keyword.other.special-method.ruby {
 color: #859900;
}
.variable.other.constant.ruby {
 color: #b58900;
}
.constant.other.symbol.ruby {
 color: #2aa198;
}
.keyword.other.special-method.ruby {
 color: #cb4b16;
}
.meta.array .support.function.construct.php {
 color: #b58900;
}
.entity.name.function.preprocessor.c, .meta.preprocessor.c.include, .meta.preprocessor.macro.c {
 color: #cb4b16;
}
.meta.preprocessor.c.include .string.quoted.other.lt-gt.include.c, .meta.preprocessor.c.include .punctuation.definition.string.begin.c, .meta.preprocessor.c.include .punctuation.definition.string.end.c {
 color: #2aa198;
}
.other.package.exclude, .other.remove {
 color: #dc322f;
}
.other.add {
 color: #2aa198;
}
.punctuation.section.group.tex, .punctuation.definition.arguments.begin.latex, .punctuation.definition.arguments.end.latex, .punctuation.definition.arguments.latex {
 color: #dc322f;
}
.meta.group.braces.tex {
 color: #b58900;
}
.string.other.math.tex {
 color: #b58900;
}
.variable.parameter.function.latex {
 color: #cb4b16;
}
.punctuation.definition.constant.math.tex {
 color: #dc322f;
}
.text.tex.latex .constant.other.math.tex, .constant.other.general.math.tex, .constant.other.general.math.tex, .constant.character.math.tex {
 color: #2aa198;
}
.string.other.math.tex {
 color: #b58900;
}
.punctuation.definition.string.begin.tex, .punctuation.definition.string.end.tex {
 color: #dc322f;
}
.keyword.control.label.latex, .text.tex.latex .constant.other.general.math.tex {
 color: #2aa198;
}
.variable.parameter.definition.label.latex {
 color: #dc322f;
}
.support.function.be.latex {
 color: #859900;
}
.support.function.section.latex {
 color: #cb4b16;
}
.support.function.general.tex {
 color: #2aa198;
}
.keyword.control.ref.latex {
 color: #2aa198;
}
.storage.type.class.python, .storage.type.function.python, .storage.modifier.global.python {
 color: #859900;
}
.support.type.exception.python {
 color: #b58900;
}
.meta.scope.for-in-loop.shell, .variable.other.loop.shell {
 color: #586e75;
}
.meta.scope.case-block.shell, .meta.scope.case-body.shell {
 color: #586e75;
}
.punctuation.definition.logical-expression.shell {
 color: #dc322f;
}
.storage.modifier.c++ {
 color: #859900;
}
.support.function.perl {
 color: #268bd2;
}
.meta.diff, .meta.diff.header {
 color: #93a1a1;
}
.meta.diff.range {
 color: #268bd2;
}
.markup.deleted {
 color: #dc322f;
}
.markup.changed {
 color: #2aa198;
}
.markup.inserted {
 color: #859900;
}
.markup.heading, .punctuation.definition.heading.markdown {
 color: #b58900;
}
.markup.quote {
 color: #859900;
}
.markup.italic {
font-style: italic;
}
.markup.bold {
font-weight: bold;
}
.markup.underline.link.markdown, .meta.link.reference .constant.other.reference.link.markdown {
 color: #2aa198;
}
.constant.other.reference.link.markdown {
 color: #6c71c4;
}
.meta.paragraph.markdown .meta.dummy.line-break {
 background-color: #eee8d5;
}
.sublimelinter.notes {
 color: #eee8d5;
 background-color: #eee8d5;
}
.sublimelinter.outline.illegal {
 color: #93a1a1;
 background-color: #93a1a1;
}
.sublimelinter.underline.illegal {
 background-color: #dc322f;
}
.sublimelinter.outline.warning {
 color: #839496;
 background-color: #839496;
}
.sublimelinter.underline.warning {
 background-color: #b58900;
}
.sublimelinter.outline.violation {
 color: #657b83;
 background-color: #657b83;
}
.sublimelinter.underline.violation {
 background-color: #cb4b16;
}
.sublimelinter.mark.warning {
 color: #b58900;
}
.sublimelinter.mark.error {
 color: #dc322f;
}
.sublimelinter.gutter-mark {
 color: #657b83;
}
.brackethighlighter.all {
 color: #93a1a1;
}
.entity.name.filename.find-in-files {
 color: #2aa198;
}
.constant.numeric.line-number.find-in-files {
 color: #93a1a1;
}
.markup.deleted.git_gutter {
 color: #dc322f;
}
.markup.inserted.git_gutter {
 color: #859900;
}
.markup.changed.git_gutter {
 color: #b58900;
}
.variable.other.readwrite.js, .variable.other.object.js, .variable.other.constant.js {
 color: #657b83;
}
}

.markdown-body {
    margin: 0 auto;
    padding: 45px;
}

@media (max-width: 767px) {
    .markdown-body {
        padding: 15px;
    }
}
    </style>
</head>
<body class="markdown-body">
<article>
<h1>Nom cheatsheet</h1>
<p>This is inspired by <a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md" title="test"><code>choosing_a_combinator.md</code></a> in that it collects a bunch of the available things in one page and shows short examples of how each works.</p>
<h2>Quick introduction to Nom</h2>
<p>For those new to Nom, most parsers and combinators actually return a function, and said function is what the input is fed to. This is what allows you to combine a bunch of parsers using combinators. This causes syntax that looks slightly odd when you're not used to it. For example, the <code>char</code> parser used directly would look like this:</p>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> my_char</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="storage type rust">char</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted single rust"><span class="punctuation definition string begin rust">&#39;</span>a<span class="punctuation definition string end rust">&#39;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre>
<p><code>input</code> is a separate column in the examples below, since it's not an argument to the function, but an argument to the result of the function.</p>
<p>The <code>output</code> column likewise is the result of calling the resulting function with the input. Feel free to re-read that last sentence a couple of time.</p>
<p>If the parser or combinator succeeded, the result will be an <code>Ok()</code> containing a tuple of the remaining input and then the actual result of the parser or combinator. The remaining input is passed back like that so that it can then be used with other parsers or combinators.</p>
<p>If you are writing a function that takes in input and returns a struct, you should write it so that it returns an <code>IResult</code> with the remaining input as well. This then allows you to use things like the <code>many0</code> combinator with your function to easily get a <code>Vec</code> of your custom structs.</p>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust">
</span></code></pre>
<h2>Basic elements</h2>
<p>Those are used to recognize the lowest level elements of your grammar, like, &quot;here is a dot&quot;, &quot;here is a number&quot;, &quot;here is a line ending&quot;. These are split up into matching a single byte or character, and matching multiple bytes or characters.</p>
<h3>Single byte or character parsers</h3>
<p>All of these parsers will return a single byte or character.</p>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.char.html">char</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.char.html">char</a></td>
<td><code>char('a')</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches one specific character</td>
</tr>
<tr>
<td></td>
<td><code>char('a')</code></td>
<td><code>&quot;cba&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Char</td>
<td>If that character isn't the immediate input, parsing fails</td>
</tr>
<tr>
<td></td>
<td><code>char('💞')</code></td>
<td><code>&quot;💞🦀&quot;</code></td>
<td>Result: <code>'💞'</code><br>Remainder: <code>&quot;🦀&quot;</code></td>
<td>Multi-byte characters work as well</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.anychar.html">anychar</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.anychar.html">anychar</a></td>
<td><code>anychar</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches any single character</td>
</tr>
<tr>
<td></td>
<td><code>anychar</code></td>
<td><code>&quot;💞🦀&quot;</code></td>
<td>Result: <code>'💞'</code><br>Remainder: <code>&quot;🦀&quot;</code></td>
<td>Multi-byte characters work as well</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.one_of.html">one_of</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.one_of.html">one_of</a></td>
<td><code>one_of(&quot;abc&quot;)</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches one of the provided characters</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.none_of.html">none_of</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.none_of.html">none_of</a></td>
<td><code>none_of(&quot;abc&quot;)</code></td>
<td><code>&quot;xyab&quot;</code></td>
<td>Result: <code>'x'</code><br>Remainder: <code>&quot;yab&quot;</code></td>
<td>Matches a single character that is anything but the provided characters</td>
</tr>
</tbody>
</table>
<h3>Sequence of bytes or characters parsers</h3>
<p>These parsers will return a slice of bytes or characters. Those suffixed with <code>0</code> can return an empty slice if they match nothing. They usually have variants that are suffixed with <code>1</code> that will refuse to match unless there's at least 1 byte or character they can match.</p>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.is_a.html">is_a</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.is_a.html">is_a</a></td>
<td><code>is_a(&quot;ab&quot;)</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>&quot;abab&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Matches a sequence of any of the characters passed as arguments</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.is_not.html">is_not</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.is_not.html">is_not</a></td>
<td><code>is_not(&quot;cd&quot;)</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>&quot;abab&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Matches a sequence of none of the characters passed as arguments</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha0.html">alpha0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alpha0.html">alpha0</a></td>
<td><code>alpha0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Matches zero or more alphabetical ASCII characters (<code>a-zA-Z</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html">alpha1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alpha1.html">alpha1</a></td>
<td><code>alpha1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Matches one or more alphabetical ASCII characters (<code>a-zA-Z</code>)</td>
</tr>
<tr>
<td></td>
<td><code>alpha0</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;123abc&quot;</code></td>
<td>Because it is allowed to return an empty string, this does not error</td>
</tr>
<tr>
<td></td>
<td><code>alpha1</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Alpha</td>
<td>This however does error, because there must be at least one alphabetical ASCII character</td>
</tr>
<tr>
<td></td>
<td><code>alpha1</code></td>
<td><code>&quot;ααα&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Alpha</td>
<td>Only ASCII counts for these, not all of the unicode alphabetical characters. (These are Greek Alphas.)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html">digit0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit0.html">digit0</a></td>
<td><code>digit0</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches zero or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html">digit1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit1.html">digit1</a></td>
<td><code>digit1</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches one or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td></td>
<td><code>digit0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;abc123&quot;</code></td>
<td>Because it is allowed to return an empty string, this does not error</td>
</tr>
<tr>
<td></td>
<td><code>digit1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Digit</td>
<td>This however does error, because there must be at least one numerical ASCII character</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric0.html">alphanumeric0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alphanumeric0.html">alphanumeric0</a></td>
<td><code>alphanumeric0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc123&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Matches zero or more alphanumeric ASCII characters (<code>a-zA-Z0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric1.html">alphanumeric1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alphanumeric1.html">alphanumeric1</a></td>
<td><code>alphanumeric1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc123&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Matches one or more alphanumeric ASCII characters (<code>a-zA-Z0-9</code>)</td>
</tr>
<tr>
<td></td>
<td><code>alphanumeric0</code></td>
<td><code>&quot;&amp;abc123&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;&amp;abc123&quot;</code></td>
<td>Because it is allowed to return an empty string, this does not error</td>
</tr>
<tr>
<td></td>
<td><code>alphanumeric1</code></td>
<td><code>&quot;&amp;abc123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: AlphaNumeric</td>
<td>This however does error, because there must be at least one alphanumeric ASCII character</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit0.html">hex_digit0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.hex_digit0.html">hex_digit0</a></td>
<td><code>hex_digit0</code></td>
<td><code>&quot;123abcghi&quot;</code></td>
<td>Result: <code>&quot;123abc&quot;</code><br>Remainder: <code>&quot;ghi&quot;</code></td>
<td>Matches zero or more hexadecimal ASCII characters (<code>0-9a-fA-F</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit1.html">hex_digit1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.hex_digit1.html">hex_digit1</a></td>
<td><code>hex_digit1</code></td>
<td><code>&quot;123abcghi&quot;</code></td>
<td>Result: <code>&quot;123abc&quot;</code><br>Remainder: <code>&quot;ghi&quot;</code></td>
<td>Matches one or more hexadecimal ASCII characters (<code>0-9a-fA-F</code>)</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag.html">tag</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.tag.html">tag</a><br>bits::complete::<a href="https://docs.rs/nom/latest/nom/bits/complete/fn.tag.html">tag</a><br>bits::streaming::<a href="https://docs.rs/nom/latest/nom/bits/streaming/fn.tag.html">tag</a></td>
<td><code>tag(&quot;hello&quot;)</code></td>
<td><code>&quot;hello world&quot;</code></td>
<td>Result: <code>&quot;hello&quot;</code><br>Remainder: <code>&quot; world&quot;</code></td>
<td>Recognizes a specific suite of characters, bytes, or bits</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag_no_case.html">tag_no_case</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.tag_no_case.html">tag_no_case</a></td>
<td><code>tag_no_case(&quot;hello&quot;)</code></td>
<td><code>&quot;HeLLo World&quot;</code></td>
<td>Result: <code>&quot;HeLLo&quot;</code><br>Remainder: <code>&quot; World&quot;</code></td>
<td>Recognizes a specific suite of characters, in a case insensitive manner</td>
</tr>
<tr>
<td></td>
<td><code>tag_no_case(&quot;γειά&quot;)</code></td>
<td><code>&quot;Γειά Κόσμο&quot;</code></td>
<td>Result: <code>&quot;Γειά&quot;</code><br>Remainder: <code>&quot; Κόσμο&quot;</code></td>
<td>This also works with non-ASCII characters. A <code>γ</code> is a lowercase <code>Γ</code>. (Greek Gamma)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.newline.html">newline</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.newline.html">newline</a></td>
<td><code>newline</code></td>
<td><code>&quot;\nhello&quot;</code></td>
<td>Result: <code>'\n'</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches a newline character, known as <code>\n</code> or <code>LF</code></td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.crlf.html">crlf</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.crlf.html">crlf</a></td>
<td><code>crlf</code></td>
<td><code>&quot;\r\nhello&quot;</code></td>
<td>Result: <code>&quot;\r\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches a carriage return followed by a newline, known as <code>\r\n</code> or <code>CRLF</code></td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html">line_ending</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.line_ending.html">line_ending</a></td>
<td><code>line_ending</code></td>
<td><code>&quot;\r\nhello&quot;</code></td>
<td>Result: <code>&quot;\r\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches an end of line, either Unix style (<code>\n</code> or <code>LF</code>) or Windows style (<code>\r\n</code> AKA <code>CRLF</code>)</td>
</tr>
<tr>
<td></td>
<td><code>line_ending</code></td>
<td><code>&quot;\nhello&quot;</code></td>
<td>Result: <code>&quot;\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Basically <code>line_ending</code> is the same as <a href="alt"><code>alt((crlf, newline))</code></a>, but has a better performance</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take.html">take</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take.html">take</a><br>bits::complete::<a href="https://docs.rs/nom/latest/nom/bits/complete/fn.take.html">take</a><br>bits::streaming::<a href="https://docs.rs/nom/latest/nom/bits/streaming/fn.take.html">take</a></td>
<td><code>take(4u8)</code></td>
<td><code>&quot;hello&quot;</code></td>
<td>Result: <code>&quot;hell&quot;</code><br>Remainder: <code>&quot;o&quot;</code></td>
<td>Takes a specific number of characters, bytes, or bits</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while.html">take_while</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while.html">take_while</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while1.html">take_while1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while1.html">take_while1</a></td>
<td><code>take_while(|c| c as u8 &gt; 64)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns the longest consecutive list of bytes for which the provided function returns true. <code>take_while1</code> does the same, but must return at least one character</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while_m_n.html">take_while_m_n</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while_m_n.html">take_while_m_n</a></td>
<td><code>take_while_m_n(4, 5, |c| is_alphanumeric(c as u8))</code></td>
<td><code>&quot;abcd123&quot;</code></td>
<td>Result: <code>&quot;abcd1&quot;</code><br>Remainder: <code>&quot;23&quot;</code></td>
<td>Like <code>take_while</code>, but with a minimum and maximum length for the match</td>
</tr>
<tr>
<td></td>
<td><code>take_while_m_n(4, 5, |c| is_alphanumeric(c as u8))</code></td>
<td><code>&quot;abcd-123&quot;</code></td>
<td>Result: <code>&quot;abcd&quot;</code><br>Remainder: <code>&quot;-123&quot;</code></td>
<td></td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_till.html">take_till</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_till.html">take_till</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_till1.html">take_till1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_till1.html">take_till1</a></td>
<td><code>take_till(|c| c as u8 &lt;= 64)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns the longest list of consecutive bytes for which the provided function returns false. <code>take_till1</code> does the same, but must return at least one character. Basically <code>take_till</code> is the same as <code>take_while</code> but with the result of the provided function negated</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until.html">take_until</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_until.html">take_until</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until1.html">take_until1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_until1.html">take_until1</a></td>
<td><code>take_until(&quot;world&quot;)</code></td>
<td><code>&quot;Hello world&quot;</code></td>
<td>Result: <code>&quot;Hello &quot;</code><br>Remainder: <code>&quot;world&quot;</code></td>
<td>Returns the longest list of bytes or characters until the provided tag is found. <code>take_until1</code> does the same, but must return at least one character</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.escaped.html">escaped</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.escaped.html">escaped</a></td>
<td><code>escaped(digit1, '\\', one_of(r#&quot;&quot;n\&quot;#))</code></td>
<td><code>r#&quot;12\&quot;34&quot;#</code></td>
<td>Result: <code>&quot;12\\\&quot;34&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>XXX: no idea why this is useful</td>
</tr>
<tr>
<td></td>
<td><code>escaped(digit1, '\\', one_of(r#&quot;&quot;n\&quot;#))</code></td>
<td><code>r#&quot;12&quot;34&quot;#</code></td>
<td>Result: <code>&quot;12&quot;</code><br>Remainder: <code>&quot;\&quot;34&quot;</code></td>
<td></td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.escaped_transform.html">escaped_transform</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.escaped_transform.html">escaped_transform</a></td>
<td><code>escaped_transform(alpha1, '\\', value(&quot;n&quot;, tag(&quot;n&quot;)))</code></td>
<td><code>r&quot;ab\ncd&quot;</code></td>
<td>Result: <code>&quot;abncd&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>XXX: no idea why this is useful</td>
</tr>
</tbody>
</table>
<h2>General combinators</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.value.html">value</a></td>
<td><code>value(1234, alpha1)</code></td>
<td><code>&quot;abc789def&quot;</code></td>
<td>Result: <code>1234</code><br>Remainder: <code>&quot;789def&quot;</code></td>
<td>Returns the provided value if the parser succeeds</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map.html">map</a></td>
<td><code>map(digit1, |s: &amp;str| s.parse::&lt;u8&gt;().unwrap())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Maps a function on the result of a parser</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_opt.html">map_opt</a></td>
<td><code>map_opt(digit1, |s: &amp;str| s.parse::&lt;u8&gt;().ok())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Same as <code>map()</code> but requires the function to return an <code>Option</code></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_res.html">map_res</a></td>
<td><code>map_res(digit1, |s: &amp;str| s.parse::&lt;u8&gt;())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Same as <code>map()</code> but requires the function to return an <code>Result</code></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.flat_map.html">flat_map</a></td>
<td><code>flat_map(u8, take)</code></td>
<td><code>&amp;[2, 90, 91, 92, 93][..]</code></td>
<td>Result: <code>[90, 91]</code><br>Remainder: <code>[92, 93]</code></td>
<td>Apply the first parser, then use its output as the argument for the second parser and apply that to the rest of the input. In this example <code>u8</code> reads a single byte as an unsigned integer, then makes that the argument to <code>take</code> causing it to read the next 2 bytes</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_parser.html">map_parser</a></td>
<td><code>map_parser(take(5u8), digit1)</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Apply the second parser on the result of the first parser</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.not.html">not</a></td>
<td><code>not(alpha1)</code></td>
<td><code>&quot;123&quot;</code></td>
<td>Result: <code>()</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Succeeds if the child parser returns an error</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.opt.html">opt</a></td>
<td><code>opt(alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>Some(&quot;abc&quot;)</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns an <code>Option</code> of the child parser. <code>Some()</code> if the child parser is succesful, and <code>None</code> if not</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.peek.html">peek</a></td>
<td><code>peek(alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;abc123&quot;</code></td>
<td>Applies the child parser but does not consume the input</td>
</tr>
<tr>
<td></td>
<td><code>alpha1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.recognize.html">recognize</a></td>
<td><code>recognize(separated_pair(alpha1, char(','), alpha1))</code></td>
<td><code>&quot;abc,def&quot;</code></td>
<td>Result: <code>&quot;abc,def&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Returns a slice of the input consumed by the child parser/combinator. No matter how complex/nested, or whether combinators throw parts away, this will return a single slice with everything that was consumed</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.rest.html">rest</a></td>
<td><code>rest</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Returns the remaining input. Mainly useful for combining with other combinators</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.rest_len.html">rest_len</a></td>
<td><code>rest_len</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>3</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Returns the length of the remaining input, does not consume anything</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.into.html">into</a></td>
<td><code>let output: IResult&lt;&amp;str, Vec&lt;u8&gt;&gt; = into(my_alpha1)</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Result: <code>[97, 98, 99, 100]</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Use Rust's <code>Into</code> trait to convert the result of a parser if possible</td>
</tr>
</tbody>
</table>
<h2>Choice combinators</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>branch::<a href="https://docs.rs/nom/latest/nom/branch/fn.alt.html">alt</a></td>
<td><code>alt((tag(&quot;ab&quot;), tag(&quot;cd&quot;)))</code></td>
<td><code>&quot;cdef&quot;</code></td>
<td>Result: <code>&quot;cd&quot;</code><br>Remainder: <code>&quot;ef&quot;</code></td>
<td>Try a list of parsers and return the result of the first successful one</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.success.html">success</a></td>
<td><code>success(1)</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>1</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Always succeeds and returns the given value without consuming any input. Useful for giving <code>alt</code> a default</td>
</tr>
<tr>
<td></td>
<td><code>alt((value(-1, char('-')), value(1, char('+')), success(1)))</code></td>
<td><code>&quot;10&quot;</code></td>
<td>Result: <code>1</code><br>Remainder: <code>&quot;10&quot;</code></td>
<td></td>
</tr>
<tr>
<td>branch::<a href="https://docs.rs/nom/latest/nom/branch/fn.permutation.html">permutation</a></td>
<td><code>permutation((tag(&quot;ab&quot;), tag(&quot;cd&quot;), tag(&quot;12&quot;)))</code></td>
<td><code>&quot;cd12abc&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;cd&quot;, &quot;12&quot;)</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Succeeds when all its child parser have succeeded, whatever the order</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.cond.html">cond</a></td>
<td><code>cond(true, alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>Some(&quot;abc&quot;)</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Return result from the parser if the first argument is true, otherwise return <code>None</code></td>
</tr>
</tbody>
</table>
<h2>Sequence combinators</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.delimited.html">delimited</a></td>
<td><code>delimited(char('('), take(2u8), char(')'))</code></td>
<td><code>&quot;(ab)cd&quot;</code></td>
<td>Result: <code>&quot;ab&quot;</code><br>Remainder: <code>&quot;cd&quot;</code></td>
<td>Returns only the second parser out of three</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.preceded.html">preceded</a></td>
<td><code>preceded(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>&quot;XY&quot;</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Returns only the second parser out of two</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.terminated.html">terminated</a></td>
<td><code>terminated(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>&quot;ab&quot;</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Returns only the result from the first parser out of two, discarding the other</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.pair.html">pair</a></td>
<td><code>pair(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;XY&quot;)</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Applies two parsers, returns their results as a tuple</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html">separated_pair</a></td>
<td><code>separated_pair(tag(&quot;hello&quot;), char(','), tag(&quot;world&quot;))</code></td>
<td><code>&quot;hello,world!&quot;</code></td>
<td>Result: <code>(&quot;hello&quot;, &quot;world&quot;)</code><br>Remainder: <code>&quot;!&quot;</code></td>
<td>Returns the results from the first and third parsers as a tuple, discarding the second</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.tuple.html">tuple</a></td>
<td><code>tuple((tag(&quot;ab&quot;), tag(&quot;XY&quot;), take(1u8)))</code></td>
<td><code>&quot;abXYZ!&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;XY&quot;, &quot;Z&quot;)</code><br>Remainder: <code>&quot;!&quot;</code></td>
<td>Chains parsers and assembles the sub results in a tuple. You can use as many child parsers as you can put elements in a tuple</td>
</tr>
</tbody>
</table>
<h2>Applying a parser multiple times</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.count.html">count</a></td>
<td><code>count(take(2u8), 3)</code></td>
<td><code>&quot;abcdefgh&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]</code><br>Remainder: <code>&quot;gh&quot;</code></td>
<td>Applies the child parser a specified number of times and returns the list of results in a <code>Vec</code></td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many0.html">many0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many1.html">many1</a></td>
<td><code>many0(tag(&quot;ab&quot;))</code></td>
<td><code>&quot;abababc&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Applies the parser 0 or more times and returns the list of results in a <code>Vec</code>. <code>many1</code> does the same operation but must return at least one element</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many_m_n.html">many_m_n</a></td>
<td><code>many_m_n(2, 2, tag(&quot;ab&quot;))</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Applies the parser at least <code>m</code> and at most <code>n</code> times and returns the list of results in a <code>Vec</code></td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many_till.html">many_till</a></td>
<td><code>many_till(tag(&quot;ab&quot;), tag(&quot;ef&quot;))</code></td>
<td><code>&quot;ababefg&quot;</code></td>
<td>Result: <code>([&quot;ab&quot;, &quot;ab&quot;], &quot;ef&quot;)</code><br>Remainder: <code>&quot;g&quot;</code></td>
<td>Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a <code>Vec</code> and the result of the second</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.separated_list0.html">separated_list0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.separated_list1.html">separated_list1</a></td>
<td><code>separated_list0(tag(&quot;,&quot;), tag(&quot;ab&quot;))</code></td>
<td><code>&quot;ab,ab,ab.&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;.&quot;</code></td>
<td>Using the first parser to match separators, returns a <code>Vec</code> of zero or more results from the second parser. <code>separated_list1</code> does the same operation but must return at least one element</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many0.html">fold_many0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many1.html">fold_many1</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many_m_n.html">fold_many_m_n</a></td>
<td><code>fold_many0(take(1u8), Vec::new, |mut acc, item| { acc.push(item); acc })</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Applies the parser 0 or more times and folds the list of return values. The <code>fold_many1</code> version must apply the parser at least one time, and <code>fold_many_m_n</code> must apply the parser at least <code>m</code> and at most <code>n</code> times</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.length_count.html">length_count</a></td>
<td><code>length_count(number, tag(&quot;ab&quot;))</code></td>
<td><code>&quot;2ababab&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;ab&quot;</code></td>
<td>Gets a number from the first parser, then applies the second parser that many times. <code>number</code> is a custom defined parser along the lines of text to integer parsers below</td>
</tr>
</tbody>
</table>
<h2>Combinators to do with completeness</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.all_consuming.html">all_consuming</a></td>
<td><code>all_consuming(pair(alpha1, number))</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>(&quot;abc&quot;, 123)</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Returns what the child parser returned if, and only if, the input is exhausted. Otherwise returns an error</td>
</tr>
<tr>
<td></td>
<td><code>all_consuming(pair(alpha1, number))</code></td>
<td><code>&quot;abc123abc&quot;</code></td>
<td>Error<br>Byte offset: 6<br>Code: Eof</td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.complete.html">complete</a></td>
<td><code>complete(nom::bytes::streaming::take(5u8))</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Complete</td>
<td>Turns an <code>Incomplete</code> result from a streaming parser into an error. The example is the equivalent of <code>nom::bytes::complete::take(5u8)</code></td>
</tr>
<tr>
<td></td>
<td><code>nom::bytes::streaming::take(5u8)</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Incomplete<br>Needed: unknown</td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.eof.html">eof</a></td>
<td><code>eof</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Returns an error if the input is not exhausted, otherwise returns the input</td>
</tr>
<tr>
<td></td>
<td><code>eof</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Eof</td>
<td></td>
</tr>
</tbody>
</table>
<h2>Numbers</h2>
<h3>Text to number</h3>
<p>Nom does not provide helper functions for converting text to integers, so here are some
various ways to get started:</p>
<h4>Generic integer with optional +/- sign</h4>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">number</span></span><span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span><span class="variable parameter rust">input</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> <span class="meta function return-type rust"><span class="punctuation separator rust">-&gt;</span> <span class="meta generic rust">IResult<span class="punctuation definition generic begin rust">&lt;</span><span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span>, T<span class="punctuation definition generic end rust">&gt;</span></span>
</span></span><span class="meta function rust"><span class="keyword other rust">where</span>
    T<span class="punctuation separator rust">:</span> FromStr,
    <span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T as <span class="meta path rust">std<span class="punctuation accessor rust">::</span></span><span class="meta path rust">str<span class="punctuation accessor rust">::</span></span>FromStr<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta path rust"><span class="punctuation accessor rust">::</span></span>Err<span class="punctuation separator rust">:</span> <span class="meta path rust">std<span class="punctuation accessor rust">::</span></span><span class="meta path rust">fmt<span class="punctuation accessor rust">::</span></span>Debug,
</span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="support function rust">map</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>
        <span class="support function rust">recognize</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">pair</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">opt</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">one_of</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>+-<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> digit1</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span>
        <span class="meta function closure rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">|</span></span></span><span class="meta function closure rust"><span class="meta function parameters rust"><span class="variable parameter rust">s</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span><span class="punctuation section parameters end rust">|</span></span> </span><span class="meta function closure rust">s.<span class="meta path rust">parse<span class="punctuation accessor rust">::</span></span><span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">unwrap</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span>
    </span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>
</span></code></pre>
<h4>Generic integer with optional - sign</h4>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">number</span></span><span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span><span class="variable parameter rust">input</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> <span class="meta function return-type rust"><span class="punctuation separator rust">-&gt;</span> <span class="meta generic rust">IResult<span class="punctuation definition generic begin rust">&lt;</span><span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span>, T<span class="punctuation definition generic end rust">&gt;</span></span>
</span></span><span class="meta function rust"><span class="keyword other rust">where</span>
    T<span class="punctuation separator rust">:</span> FromStr,
    <span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T as <span class="meta path rust">std<span class="punctuation accessor rust">::</span></span><span class="meta path rust">str<span class="punctuation accessor rust">::</span></span>FromStr<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta path rust"><span class="punctuation accessor rust">::</span></span>Err<span class="punctuation separator rust">:</span> <span class="meta path rust">std<span class="punctuation accessor rust">::</span></span><span class="meta path rust">fmt<span class="punctuation accessor rust">::</span></span>Debug,
</span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="support function rust">map</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>
        <span class="support function rust">recognize</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">pair</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">opt</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="support function rust">tag</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>-<span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> digit1</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span>
        <span class="meta function closure rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">|</span></span></span><span class="meta function closure rust"><span class="meta function parameters rust"><span class="variable parameter rust">s</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span><span class="punctuation section parameters end rust">|</span></span> </span><span class="meta function closure rust">s.<span class="meta path rust">parse<span class="punctuation accessor rust">::</span></span><span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span>T<span class="punctuation definition generic end rust">&gt;</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">unwrap</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span>
    </span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>
</span></code></pre>
<h4><code>usize</code></h4>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">number</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span><span class="variable parameter rust">input</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> <span class="meta function return-type rust"><span class="punctuation separator rust">-&gt;</span> <span class="meta generic rust">IResult<span class="punctuation definition generic begin rust">&lt;</span><span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span>, <span class="storage type rust">usize</span><span class="punctuation definition generic end rust">&gt;</span></span></span> </span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="support function rust">map</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>digit1<span class="punctuation separator rust">,</span> <span class="meta function closure rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">|</span></span></span><span class="meta function closure rust"><span class="meta function parameters rust"><span class="variable parameter rust">s</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span><span class="punctuation section parameters end rust">|</span></span> </span><span class="meta function closure rust">s.<span class="meta path rust">parse<span class="punctuation accessor rust">::</span></span><span class="meta generic rust"><span class="punctuation definition generic begin rust">&lt;</span><span class="storage type rust">usize</span><span class="punctuation definition generic end rust">&gt;</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">unwrap</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>
</span></code></pre>
<h4>Provided integer parsers</h4>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.double.html">double</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.double.html">double</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.float.html">float</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.float.html">float</a></td>
<td><code>double</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>1.23</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Recognizes floating point number in a byte string and returns an <code>f64</code>.  <code>float</code> does the same for <code>f32</code></td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.recognize_float.html">recognize_float</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.recognize_float.html">recognize_float</a></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>&quot;123E-02&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Recognizes floating point number in a byte string and returns the corresponding slice</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.hex_u32.html">hex_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.hex_u32.html">hex_u32</a></td>
<td><code>hex_u32</code></td>
<td><code>b&quot;abcxyz&quot;</code></td>
<td>Result: <code>2748</code><br>Remainder: <code>[120, 121, 122]</code></td>
<td>Recognizes hex-encoded <code>u32</code></td>
</tr>
</tbody>
</table>
<h3>Binary to number</h3>
<p>Parsing integers from binary formats can be done in two ways: With parser functions, or combinators with configurable endianness:</p>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i8.html">i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i8.html">i8</a></td>
<td><code>i8</code></td>
<td><code>&amp;[0xf0][..]</code></td>
<td>Result: <code>-16</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a signed integer. Endianness does not matter for single byte numbers, so there's no <code>nom::Endianness</code> parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i16.html">i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i16.html">i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i24.html">i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i24.html">i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i32.html">i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i32.html">i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i64.html">i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i64.html">i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i128.html">i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i128.html">i128</a></td>
<td><code>i16(Endianness::Big)</code></td>
<td><code>&amp;[0xff, 0x00][..]</code></td>
<td>Result: <code>-256</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a signed integer. Various bitsize functions are available. Endianness handled according to parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u8.html">u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u8.html">u8</a></td>
<td><code>u8</code></td>
<td><code>&amp;[0xf0][..]</code></td>
<td>Result: <code>240</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a unsigned integer. Endianness does not matter for single byte numbers, so there's no <code>nom::Endianness</code> parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u16.html">u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u16.html">u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u24.html">u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u24.html">u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u32.html">u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u32.html">u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u64.html">u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u64.html">u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u128.html">u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u128.html">u128</a></td>
<td><code>u16(Endianness::Big)</code></td>
<td><code>&amp;[0xff, 0x00][..]</code></td>
<td>Result: <code>65280</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a unsigned integer. Various bitsize functions are available. Endianness handled according to parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i8.html">be_i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i8.html">be_i8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i16.html">be_i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i16.html">be_i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i24.html">be_i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i24.html">be_i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i32.html">be_i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i32.html">be_i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i64.html">be_i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i64.html">be_i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i128.html">be_i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i128.html">be_i128</a></td>
<td><code>be_i16</code></td>
<td><code>&amp;[0xff, 0xaa][..]</code></td>
<td>Result: <code>-86</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian signed integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u8.html">be_u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u8.html">be_u8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u16.html">be_u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u16.html">be_u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u24.html">be_u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u24.html">be_u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u32.html">be_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u32.html">be_u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u64.html">be_u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u64.html">be_u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u128.html">be_u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u128.html">be_u128</a></td>
<td><code>be_u16</code></td>
<td><code>&amp;[0xff, 0xaa][..]</code></td>
<td>Result: <code>65450</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian unsigned integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i8.html">le_i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i8.html">le_i8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i16.html">le_i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i16.html">le_i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i24.html">le_i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i24.html">le_i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i32.html">le_i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i32.html">le_i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i64.html">le_i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i64.html">le_i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i128.html">le_i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i128.html">le_i128</a></td>
<td><code>le_i16</code></td>
<td><code>&amp;[0xff, 0xaa][..]</code></td>
<td>Result: <code>-21761</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian signed integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u8.html">le_u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u8.html">le_u8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u16.html">le_u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u16.html">le_u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u24.html">le_u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u24.html">le_u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u32.html">le_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u32.html">le_u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u64.html">le_u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u64.html">le_u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u128.html">le_u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u128.html">le_u128</a></td>
<td><code>le_u16</code></td>
<td><code>&amp;[0xff, 0xaa][..]</code></td>
<td>Result: <code>43775</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian unsigned integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_f32.html">be_f32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_f32.html">be_f32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_f64.html">be_f64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_f64.html">be_f64</a></td>
<td><code>be_f32</code></td>
<td><code>&amp;[0x41, 0x48, 0x00, 0x00][..]</code></td>
<td>Result: <code>12.5</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian floating point number</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_f32.html">le_f32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_f32.html">le_f32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_f64.html">le_f64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_f64.html">le_f64</a></td>
<td><code>le_f32</code></td>
<td><code>&amp;[0x00, 0x00, 0x48, 0x41][..]</code></td>
<td>Result: <code>12.5</code><br>Remainder: <code>[]</code></td>
<td>Recognizes a big endian floating point number</td>
</tr>
</tbody>
</table>
<h1>Fin</h1>
</article>
</body>
</html>
