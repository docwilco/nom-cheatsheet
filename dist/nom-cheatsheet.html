<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Nom Cheatsheet</title>
    <style>
/* Downloaded from https://raw.githubusercontent.com/sindresorhus/github-markdown-css/gh-pages/github-markdown.css */
@media (prefers-color-scheme: dark) {
  .markdown-body {
    color-scheme: dark;
    --color-prettylights-syntax-comment: #8b949e;
    --color-prettylights-syntax-constant: #79c0ff;
    --color-prettylights-syntax-entity: #d2a8ff;
    --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
    --color-prettylights-syntax-entity-tag: #7ee787;
    --color-prettylights-syntax-keyword: #ff7b72;
    --color-prettylights-syntax-string: #a5d6ff;
    --color-prettylights-syntax-variable: #ffa657;
    --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
    --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
    --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
    --color-prettylights-syntax-carriage-return-text: #f0f6fc;
    --color-prettylights-syntax-carriage-return-bg: #b62324;
    --color-prettylights-syntax-string-regexp: #7ee787;
    --color-prettylights-syntax-markup-list: #f2cc60;
    --color-prettylights-syntax-markup-heading: #1f6feb;
    --color-prettylights-syntax-markup-italic: #c9d1d9;
    --color-prettylights-syntax-markup-bold: #c9d1d9;
    --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
    --color-prettylights-syntax-markup-deleted-bg: #67060c;
    --color-prettylights-syntax-markup-inserted-text: #aff5b4;
    --color-prettylights-syntax-markup-inserted-bg: #033a16;
    --color-prettylights-syntax-markup-changed-text: #ffdfb6;
    --color-prettylights-syntax-markup-changed-bg: #5a1e02;
    --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
    --color-prettylights-syntax-markup-ignored-bg: #1158c7;
    --color-prettylights-syntax-meta-diff-range: #d2a8ff;
    --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
    --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
    --color-fg-default: #c9d1d9;
    --color-fg-muted: #8b949e;
    --color-fg-subtle: #484f58;
    --color-canvas-default: #0d1117;
    --color-canvas-subtle: #161b22;
    --color-border-default: #30363d;
    --color-border-muted: #21262d;
    --color-neutral-muted: rgba(110,118,129,0.4);
    --color-accent-fg: #58a6ff;
    --color-accent-emphasis: #1f6feb;
    --color-attention-subtle: rgba(187,128,9,0.15);
    --color-danger-fg: #f85149;
  }
}

@media (prefers-color-scheme: light) {
  .markdown-body {
    color-scheme: light;
    --color-prettylights-syntax-comment: #6e7781;
    --color-prettylights-syntax-constant: #0550ae;
    --color-prettylights-syntax-entity: #8250df;
    --color-prettylights-syntax-storage-modifier-import: #24292f;
    --color-prettylights-syntax-entity-tag: #116329;
    --color-prettylights-syntax-keyword: #cf222e;
    --color-prettylights-syntax-string: #0a3069;
    --color-prettylights-syntax-variable: #953800;
    --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
    --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
    --color-prettylights-syntax-invalid-illegal-bg: #82071e;
    --color-prettylights-syntax-carriage-return-text: #f6f8fa;
    --color-prettylights-syntax-carriage-return-bg: #cf222e;
    --color-prettylights-syntax-string-regexp: #116329;
    --color-prettylights-syntax-markup-list: #3b2300;
    --color-prettylights-syntax-markup-heading: #0550ae;
    --color-prettylights-syntax-markup-italic: #24292f;
    --color-prettylights-syntax-markup-bold: #24292f;
    --color-prettylights-syntax-markup-deleted-text: #82071e;
    --color-prettylights-syntax-markup-deleted-bg: #FFEBE9;
    --color-prettylights-syntax-markup-inserted-text: #116329;
    --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
    --color-prettylights-syntax-markup-changed-text: #953800;
    --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
    --color-prettylights-syntax-markup-ignored-text: #eaeef2;
    --color-prettylights-syntax-markup-ignored-bg: #0550ae;
    --color-prettylights-syntax-meta-diff-range: #8250df;
    --color-prettylights-syntax-brackethighlighter-angle: #57606a;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
    --color-prettylights-syntax-constant-other-reference-link: #0a3069;
    --color-fg-default: #24292f;
    --color-fg-muted: #57606a;
    --color-fg-subtle: #6e7781;
    --color-canvas-default: #ffffff;
    --color-canvas-subtle: #f6f8fa;
    --color-border-default: #d0d7de;
    --color-border-muted: hsla(210,18%,87%,1);
    --color-neutral-muted: rgba(175,184,193,0.2);
    --color-accent-fg: #0969da;
    --color-accent-emphasis: #0969da;
    --color-attention-subtle: #fff8c5;
    --color-danger-fg: #cf222e;
  }
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--color-fg-default);
  background-color: var(--color-canvas-default);
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body h1:hover .anchor .octicon-link:before,
.markdown-body h2:hover .anchor .octicon-link:before,
.markdown-body h3:hover .anchor .octicon-link:before,
.markdown-body h4:hover .anchor .octicon-link:before,
.markdown-body h5:hover .anchor .octicon-link:before,
.markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.markdown-body details,
.markdown-body figcaption,
.markdown-body figure {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body [hidden] {
  display: none !important;
}

.markdown-body a {
  background-color: transparent;
  color: var(--color-accent-fg);
  text-decoration: none;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body abbr[title] {
  border-bottom: none;
  text-decoration: underline dotted;
}

.markdown-body b,
.markdown-body strong {
  font-weight: 600;
}

.markdown-body dfn {
  font-style: italic;
}

.markdown-body h1 {
  margin: .67em 0;
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body mark {
  background-color: var(--color-attention-subtle);
  color: var(--color-text-primary);
}

.markdown-body small {
  font-size: 90%;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body sup {
  top: -0.5em;
}

.markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--color-canvas-default);
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body figure {
  margin: 1em 40px;
}

.markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--color-border-muted);
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--color-border-default);
  border: 0;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body [type=button],
.markdown-body [type=reset],
.markdown-body [type=submit] {
  -webkit-appearance: button;
}

.markdown-body [type=button]::-moz-focus-inner,
.markdown-body [type=reset]::-moz-focus-inner,
.markdown-body [type=submit]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

.markdown-body [type=button]:-moz-focusring,
.markdown-body [type=reset]:-moz-focusring,
.markdown-body [type=submit]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

.markdown-body [type=checkbox],
.markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body [type=number]::-webkit-inner-spin-button,
.markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.markdown-body [type=search] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

.markdown-body [type=search]::-webkit-search-cancel-button,
.markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
}

.markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--color-fg-default);
  vertical-align: middle;
  background-color: var(--color-canvas-subtle);
  border: solid 1px var(--color-neutral-muted);
  border-bottom-color: var(--color-neutral-muted);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--color-neutral-muted);
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h2 {
  font-weight: 600;
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body h3 {
  font-weight: 600;
  font-size: 1.25em;
}

.markdown-body h4 {
  font-weight: 600;
  font-size: 1em;
}

.markdown-body h5 {
  font-weight: 600;
  font-size: .875em;
}

.markdown-body h6 {
  font-weight: 600;
  font-size: .85em;
  color: var(--color-fg-muted);
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--color-fg-muted);
  border-left: .25em solid var(--color-border-default);
}

.markdown-body ul,
.markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body tt,
.markdown-body code {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-body ::placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.markdown-body input::-webkit-outer-spin-button,
.markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.markdown-body [data-catalyst] {
  display: block;
}

.markdown-body g-emoji {
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: 400;
  line-height: 1;
  vertical-align: -0.075em;
}

.markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .absent {
  color: var(--color-danger-fg);
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body sup>a::before {
  content: "[";
}

.markdown-body sup>a::after {
  content: "]";
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: var(--color-fg-default);
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.markdown-body ol[type=a] {
  list-style-type: lower-alpha;
}

.markdown-body ol[type=i] {
  list-style-type: lower-roman;
}

.markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--color-border-default);
}

.markdown-body table tr {
  background-color: var(--color-canvas-default);
  border-top: 1px solid var(--color-border-muted);
}

.markdown-body table tr:nth-child(2n) {
  background-color: var(--color-canvas-subtle);
}

.markdown-body table img {
  background-color: transparent;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--color-border-default);
}

.markdown-body span.frame span img {
  display: block;
  float: left;
}

.markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--color-fg-default);
}

.markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.markdown-body span.float-left span {
  margin: 13px 0 0;
}

.markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body code,
.markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  background-color: var(--color-neutral-muted);
  border-radius: 6px;
}

.markdown-body code br,
.markdown-body tt br {
  display: none;
}

.markdown-body del code {
  text-decoration: inherit;
}

.markdown-body pre code {
  font-size: 100%;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: var(--color-canvas-subtle);
  border-radius: 6px;
}

.markdown-body pre code,
.markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .csv-data td,
.markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--color-canvas-default);
  border: 0;
}

.markdown-body .csv-data tr {
  border-top: 0;
}

.markdown-body .csv-data th {
  font-weight: 600;
  background: var(--color-canvas-subtle);
  border-top: 0;
}

.markdown-body .footnotes {
  font-size: 12px;
  color: var(--color-fg-muted);
  border-top: 1px solid var(--color-border-default);
}

.markdown-body .footnotes ol {
  padding-left: 16px;
}

.markdown-body .footnotes li {
  position: relative;
}

.markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--color-accent-emphasis);
  border-radius: 6px;
}

.markdown-body .footnotes li:target {
  color: var(--color-fg-default);
}

.markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item label {
  font-weight: 400;
}

.markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item .handle {
  display: none;
}

.markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}
@media (prefers-color-scheme: dark) {/*
 * theme "Solarized (dark)" generated by syntect
 */

.code {
 color: #839496;
 background-color: #002b36;
}

.comment, .meta.documentation {
 color: #586e75;
}
.string {
 color: #2aa198;
}
.string.regexp {
 color: #2aa198;
}
.constant.character.escape {
 color: #dc322f;
}
.constant.numeric {
 color: #6c71c4;
}
.variable {
 color: #268bd2;
}
.variable.function {
 color: #b58900;
}
.variable.language {
 color: #d33682;
}
.keyword {
 color: #859900;
}
.meta.import .keyword, .keyword.control.import, .keyword.control.import.from, .keyword.other.import, .keyword.control.at-rule.include, .keyword.control.at-rule.import {
 color: #cb4b16;
}
.keyword.operator.comparison, .keyword.operator.assignment, .keyword.operator.arithmetic {
 color: #657b83;
}
.storage {
 color: #859900;
}
.storage.modifier {
 color: #93a1a1;
}
.keyword.control.class, .entity.name, .entity.name.class, .entity.name.type.class {
 color: #b58900;
}
.entity.other.inherited-class {
 color: #268bd2;
}
.entity.other.attribute-name {
 color: #b58900;
}
.support, .support.type, .support.class {
 color: #859900;
}
.entity.name.function {
 color: #b58900;
}
.punctuation.definition.variable {
 color: #859900;
}
.constant, .constant.language, .meta.preprocessor {
 color: #b58900;
}
.entity.name.section {
 color: #cb4b16;
}
.support.function.construct, .keyword.other.new {
 color: #dc322f;
}
.constant.character, .constant.other {
 color: #cb4b16;
}
.entity.name.tag {
 color: #268bd2;
}
.punctuation.definition.tag.html, .punctuation.definition.tag.begin, .punctuation.definition.tag.end {
 color: #586e75;
}
.support.function {
 color: #859900;
}
.punctuation.separator.continuation {
 color: #dc322f;
}
.storage.type {
 color: #268bd2;
}
.support.type.exception {
 color: #cb4b16;
}
.keyword.other.special-method {
 color: #cb4b16;
}
.invalid {
 background-color: #6e2e32;
}
.string.quoted.double, .string.quoted.single {
 color: #2aa198;
}
.punctuation.definition.string {
 color: #839496;
}
.meta.brace.square, .punctuation.section.brackets {
 color: #268bd2;
}
.meta.brace.round, .meta.brace.curly, .punctuation.section, .punctuation.section.block, .punctuation.definition.parameters, .punctuation.section.group {
 color: #657b83;
}
.support.constant.color, .invalid.deprecated.color.w3c-non-standard-color-name.scss {
 color: #b58900;
}
.meta.selector.css {
 color: #657b83;
}
.entity.name.tag.css, .entity.name.tag.scss, .source.less .keyword.control.html.elements, .source.sass .keyword.control.untitled {
 color: #b58900;
}
.entity.other.attribute-name.class {
 color: #b58900;
}
.entity.other.attribute-name.id {
 color: #b58900;
}
.entity.other.attribute-name.pseudo-element, .entity.other.attribute-name.tag.pseudo-element, .entity.other.attribute-name.pseudo-class, .entity.other.attribute-name.tag.pseudo-class {
 color: #268bd2;
}
.text.html.basic .meta.tag.other.html, .text.html.basic .meta.tag.any.html, .text.html.basic .meta.tag.block.any, .text.html.basic .meta.tag.inline.any, .text.html.basic .meta.tag.structure.any.html, .text.html.basic .source.js.embedded.html, .punctuation.separator.key-value.html {
 color: #657b83;
}
.text.html.basic .entity.other.attribute-name.html, .meta.tag.xml .entity.other.attribute-name {
 color: #b58900;
}
.keyword.other.special-method.ruby {
 color: #859900;
}
.variable.other.constant.ruby {
 color: #b58900;
}
.constant.other.symbol.ruby {
 color: #2aa198;
}
.keyword.other.special-method.ruby {
 color: #cb4b16;
}
.meta.array .support.function.construct.php {
 color: #b58900;
}
.entity.name.function.preprocessor.c, .meta.preprocessor.c.include, .meta.preprocessor.macro.c {
 color: #cb4b16;
}
.meta.preprocessor.c.include .string.quoted.other.lt-gt.include.c, .meta.preprocessor.c.include .punctuation.definition.string.begin.c, .meta.preprocessor.c.include .punctuation.definition.string.end.c {
 color: #2aa198;
}
.other.package.exclude, .other.remove {
 color: #dc322f;
}
.other.add {
 color: #2aa198;
}
.punctuation.section.group.tex, .punctuation.definition.arguments.begin.latex, .punctuation.definition.arguments.end.latex, .punctuation.definition.arguments.latex {
 color: #dc322f;
}
.meta.group.braces.tex {
 color: #b58900;
}
.string.other.math.tex {
 color: #b58900;
}
.variable.parameter.function.latex {
 color: #cb4b16;
}
.punctuation.definition.constant.math.tex {
 color: #dc322f;
}
.text.tex.latex .constant.other.math.tex, .constant.other.general.math.tex, .constant.other.general.math.tex, .constant.character.math.tex {
 color: #2aa198;
}
.string.other.math.tex {
 color: #b58900;
}
.punctuation.definition.string.begin.tex, .punctuation.definition.string.end.tex {
 color: #dc322f;
}
.keyword.control.label.latex, .text.tex.latex .constant.other.general.math.tex {
 color: #2aa198;
}
.variable.parameter.definition.label.latex {
 color: #dc322f;
}
.support.function.be.latex {
 color: #859900;
}
.support.function.section.latex {
 color: #cb4b16;
}
.support.function.general.tex {
 color: #2aa198;
}
.keyword.control.ref.latex {
 color: #2aa198;
}
.storage.type.class.python, .storage.type.function.python, .storage.modifier.global.python {
 color: #859900;
}
.support.type.exception.python {
 color: #b58900;
}
.meta.scope.for-in-loop.shell, .variable.other.loop.shell {
 color: #93a1a1;
}
.meta.scope.case-block.shell, .meta.scope.case-body.shell {
 color: #93a1a1;
}
.punctuation.definition.logical-expression.shell {
 color: #dc322f;
}
.storage.modifier.c++ {
 color: #859900;
}
.support.function.perl {
 color: #268bd2;
}
.meta.diff, .meta.diff.header {
 color: #586e75;
}
.meta.diff.range {
 color: #268bd2;
}
.markup.deleted {
 color: #dc322f;
}
.markup.changed {
 color: #2aa198;
}
.markup.inserted {
 color: #859900;
}
.markup.heading, .punctuation.definition.heading.markdown {
 color: #b58900;
}
.markup.quote {
 color: #859900;
}
.markup.italic {
font-style: italic;
}
.markup.bold {
font-weight: bold;
}
.markup.underline.link.markdown, .meta.link.reference .constant.other.reference.link.markdown {
 color: #2aa198;
}
.constant.other.reference.link.markdown {
 color: #6c71c4;
}
.meta.paragraph.markdown .meta.dummy.line-break {
 background-color: #586e75;
}
.sublimelinter.notes {
 color: #586e75;
 background-color: #586e75;
}
.sublimelinter.outline.illegal {
 color: #586e75;
 background-color: #586e75;
}
.sublimelinter.underline.illegal {
 background-color: #dc322f;
}
.sublimelinter.outline.warning {
 color: #839496;
 background-color: #839496;
}
.sublimelinter.underline.warning {
 background-color: #b58900;
}
.sublimelinter.outline.violation {
 color: #657b83;
 background-color: #657b83;
}
.sublimelinter.underline.violation {
 background-color: #cb4b16;
}
.sublimelinter.mark.warning {
 color: #b58900;
}
.sublimelinter.mark.error {
 color: #dc322f;
}
.sublimelinter.gutter-mark {
 color: #657b83;
}
.brackethighlighter.all {
 color: #586e75;
}
.entity.name.filename.find-in-files {
 color: #2aa198;
}
.constant.numeric.line-number.find-in-files {
 color: #586e75;
}
.markup.deleted.git_gutter {
 color: #dc322f;
}
.markup.inserted.git_gutter {
 color: #859900;
}
.markup.changed.git_gutter {
 color: #b58900;
}
.variable.other.readwrite.js, .variable.other.object.js, .variable.other.constant.js {
 color: #839496;
}
}
@media (prefers-color-scheme: light) {/*
 * theme "Solarized (light)" generated by syntect
 */

.code {
 color: #657b83;
 background-color: #fdf6e3;
}

.comment, .meta.documentation {
 color: #93a1a1;
}
.string {
 color: #2aa198;
}
.string.regexp {
 color: #2aa198;
}
.constant.character.escape {
 color: #dc322f;
}
.constant.numeric {
 color: #6c71c4;
}
.variable {
 color: #268bd2;
}
.variable.function {
 color: #b58900;
}
.variable.language {
 color: #d33682;
}
.keyword {
 color: #859900;
}
.meta.import .keyword, .keyword.control.import, .keyword.control.import.from, .keyword.other.import, .keyword.control.at-rule.include, .keyword.control.at-rule.import {
 color: #cb4b16;
}
.keyword.operator.comparison, .keyword.operator.assignment, .keyword.operator.arithmetic {
 color: #657b83;
}
.storage {
 color: #859900;
}
.storage.modifier {
 color: #586e75;
}
.keyword.control.class, .entity.name, .entity.name.class, .entity.name.type.class {
 color: #b58900;
}
.entity.other.inherited-class {
 color: #268bd2;
}
.entity.other.attribute-name {
 color: #b58900;
}
.support, .support.type, .support.class {
 color: #859900;
}
.entity.name.function {
 color: #b58900;
}
.punctuation.definition.variable {
 color: #859900;
}
.constant, .constant.language, .meta.preprocessor {
 color: #b58900;
}
.entity.name.section {
 color: #cb4b16;
}
.support.function.construct, .keyword.other.new {
 color: #dc322f;
}
.constant.character, .constant.other {
 color: #cb4b16;
}
.entity.name.tag {
 color: #268bd2;
}
.punctuation.definition.tag.html, .punctuation.definition.tag.begin, .punctuation.definition.tag.end {
 color: #93a1a1;
}
.support.function {
 color: #859900;
}
.punctuation.separator.continuation {
 color: #dc322f;
}
.storage.type {
 color: #268bd2;
}
.support.type.exception {
 color: #cb4b16;
}
.keyword.other.special-method {
 color: #cb4b16;
}
.invalid {
 background-color: #ec9489;
}
.string.quoted.double, .string.quoted.single {
 color: #2aa198;
}
.punctuation.definition.string {
 color: #839496;
}
.meta.brace.square, .punctuation.section.brackets {
 color: #268bd2;
}
.meta.brace.round, .meta.brace.curly, .punctuation.section, .punctuation.section.block, .punctuation.definition.parameters, .punctuation.section.group {
 color: #657b83;
}
.support.constant.color, .invalid.deprecated.color.w3c-non-standard-color-name.scss {
 color: #b58900;
}
.meta.selector.css {
 color: #657b83;
}
.entity.name.tag.css, .entity.name.tag.scss, .source.less .keyword.control.html.elements, .source.sass .keyword.control.untitled {
 color: #b58900;
}
.entity.other.attribute-name.class {
 color: #b58900;
}
.entity.other.attribute-name.id {
 color: #b58900;
}
.entity.other.attribute-name.pseudo-element, .entity.other.attribute-name.tag.pseudo-element, .entity.other.attribute-name.pseudo-class, .entity.other.attribute-name.tag.pseudo-class {
 color: #268bd2;
}
.text.html.basic .meta.tag.other.html, .text.html.basic .meta.tag.any.html, .text.html.basic .meta.tag.block.any, .text.html.basic .meta.tag.inline.any, .text.html.basic .meta.tag.structure.any.html, .text.html.basic .source.js.embedded.html, .punctuation.separator.key-value.html {
 color: #657b83;
}
.text.html.basic .entity.other.attribute-name.html, .meta.tag.xml .entity.other.attribute-name {
 color: #b58900;
}
.keyword.other.special-method.ruby {
 color: #859900;
}
.variable.other.constant.ruby {
 color: #b58900;
}
.constant.other.symbol.ruby {
 color: #2aa198;
}
.keyword.other.special-method.ruby {
 color: #cb4b16;
}
.meta.array .support.function.construct.php {
 color: #b58900;
}
.entity.name.function.preprocessor.c, .meta.preprocessor.c.include, .meta.preprocessor.macro.c {
 color: #cb4b16;
}
.meta.preprocessor.c.include .string.quoted.other.lt-gt.include.c, .meta.preprocessor.c.include .punctuation.definition.string.begin.c, .meta.preprocessor.c.include .punctuation.definition.string.end.c {
 color: #2aa198;
}
.other.package.exclude, .other.remove {
 color: #dc322f;
}
.other.add {
 color: #2aa198;
}
.punctuation.section.group.tex, .punctuation.definition.arguments.begin.latex, .punctuation.definition.arguments.end.latex, .punctuation.definition.arguments.latex {
 color: #dc322f;
}
.meta.group.braces.tex {
 color: #b58900;
}
.string.other.math.tex {
 color: #b58900;
}
.variable.parameter.function.latex {
 color: #cb4b16;
}
.punctuation.definition.constant.math.tex {
 color: #dc322f;
}
.text.tex.latex .constant.other.math.tex, .constant.other.general.math.tex, .constant.other.general.math.tex, .constant.character.math.tex {
 color: #2aa198;
}
.string.other.math.tex {
 color: #b58900;
}
.punctuation.definition.string.begin.tex, .punctuation.definition.string.end.tex {
 color: #dc322f;
}
.keyword.control.label.latex, .text.tex.latex .constant.other.general.math.tex {
 color: #2aa198;
}
.variable.parameter.definition.label.latex {
 color: #dc322f;
}
.support.function.be.latex {
 color: #859900;
}
.support.function.section.latex {
 color: #cb4b16;
}
.support.function.general.tex {
 color: #2aa198;
}
.keyword.control.ref.latex {
 color: #2aa198;
}
.storage.type.class.python, .storage.type.function.python, .storage.modifier.global.python {
 color: #859900;
}
.support.type.exception.python {
 color: #b58900;
}
.meta.scope.for-in-loop.shell, .variable.other.loop.shell {
 color: #586e75;
}
.meta.scope.case-block.shell, .meta.scope.case-body.shell {
 color: #586e75;
}
.punctuation.definition.logical-expression.shell {
 color: #dc322f;
}
.storage.modifier.c++ {
 color: #859900;
}
.support.function.perl {
 color: #268bd2;
}
.meta.diff, .meta.diff.header {
 color: #93a1a1;
}
.meta.diff.range {
 color: #268bd2;
}
.markup.deleted {
 color: #dc322f;
}
.markup.changed {
 color: #2aa198;
}
.markup.inserted {
 color: #859900;
}
.markup.heading, .punctuation.definition.heading.markdown {
 color: #b58900;
}
.markup.quote {
 color: #859900;
}
.markup.italic {
font-style: italic;
}
.markup.bold {
font-weight: bold;
}
.markup.underline.link.markdown, .meta.link.reference .constant.other.reference.link.markdown {
 color: #2aa198;
}
.constant.other.reference.link.markdown {
 color: #6c71c4;
}
.meta.paragraph.markdown .meta.dummy.line-break {
 background-color: #eee8d5;
}
.sublimelinter.notes {
 color: #eee8d5;
 background-color: #eee8d5;
}
.sublimelinter.outline.illegal {
 color: #93a1a1;
 background-color: #93a1a1;
}
.sublimelinter.underline.illegal {
 background-color: #dc322f;
}
.sublimelinter.outline.warning {
 color: #839496;
 background-color: #839496;
}
.sublimelinter.underline.warning {
 background-color: #b58900;
}
.sublimelinter.outline.violation {
 color: #657b83;
 background-color: #657b83;
}
.sublimelinter.underline.violation {
 background-color: #cb4b16;
}
.sublimelinter.mark.warning {
 color: #b58900;
}
.sublimelinter.mark.error {
 color: #dc322f;
}
.sublimelinter.gutter-mark {
 color: #657b83;
}
.brackethighlighter.all {
 color: #93a1a1;
}
.entity.name.filename.find-in-files {
 color: #2aa198;
}
.constant.numeric.line-number.find-in-files {
 color: #93a1a1;
}
.markup.deleted.git_gutter {
 color: #dc322f;
}
.markup.inserted.git_gutter {
 color: #859900;
}
.markup.changed.git_gutter {
 color: #b58900;
}
.variable.other.readwrite.js, .variable.other.object.js, .variable.other.constant.js {
 color: #657b83;
}
}

.markdown-body {
    margin: 0 auto;
    padding: 45px;
}

@media (max-width: 767px) {
    .markdown-body {
        padding: 15px;
    }
}
    </style>
</head>
<body class="markdown-body">
<article>
<h1><a href="#nom-cheatsheet" aria-hidden="true" class="anchor" id="nom-cheatsheet"></a>Nom cheatsheet</h1>
<p>This is inspired by <a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md" title="test"><code>choosing_a_combinator.md</code></a> in that it collects a bunch of the available things in one page and shows short examples of how each works.</p>
<h2><a href="#quick-introduction-to-nom" aria-hidden="true" class="anchor" id="quick-introduction-to-nom"></a>Quick introduction to Nom</h2>
<p>For those new to Nom, most parsers and combinators actually return a function, and said function is what the input is fed to. This is what allows you to combine a bunch of parsers using combinators. This causes syntax that looks slightly odd when you're not used to it. For example, the <code>char</code> parser used directly would look like this:</p>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> my_char</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="storage type rust">char</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted single rust"><span class="punctuation definition string begin rust">&#39;</span>a<span class="punctuation definition string end rust">&#39;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
</span></code></pre>
<p>As you can see, there's two sets of parentheses after <code>char</code>. The first set is the arguments to the <code>char</code> function, and makes a new function that is a parser that only accepts a single <code>a</code>. Then the second set is the actual call to that parser with the input. The <code>?</code> at the end is Rust's typical way of handling errors, and is used to return early if the parser fails. Nom parsers use <code>IResult</code> as their return type, which is a rather specific type alias of <code>Result</code>.</p>
<p>In all the examples in the tables below, <code>input</code> is a separate column since it's not an argument to the function, but an argument to the result of the function.</p>
<p>The <code>output</code> column likewise is the result of calling the parser, but for <code>Ok()</code> results, the result and the remaining input are shown in a nice way, instead of <code>Ok((&quot;remaining input&quot;, &quot;result&quot;))</code>, which can be a bit hard to read.</p>
<p>If the parser or combinator succeeded, the result will be an <code>Ok()</code> containing a tuple of the remaining input and then the actual result of the parser or combinator. The remaining input is passed back like that so that it can then be used with other parsers or combinators. That is why the <code>input</code> variable is rebound in the examples above.</p>
<p>If you are writing a function that takes in input and returns a struct, you should write it so that it returns an <code>IResult</code> with the remaining input as well. This then allows you to use things like the <code>many0</code> combinator with your function to easily get a <code>Vec</code> of your custom structs.</p>
<pre class="syntax-highlighting"><code class="language-rust"><span class="source rust"><span class="keyword other rust">use</span> <span class="meta path rust">nom<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="meta path rust">character<span class="punctuation accessor rust">::</span></span><span class="meta path rust">complete<span class="punctuation accessor rust">::</span></span><span class="meta block rust"><span class="punctuation section block begin rust">{</span><span class="storage type rust">char</span><span class="punctuation separator rust">,</span> <span class="storage type rust">i32</span><span class="punctuation separator rust">,</span> line_ending<span class="punctuation separator rust">,</span> newline</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation separator rust">,</span>
    <span class="meta path rust">multi<span class="punctuation accessor rust">::</span></span>separated_list0<span class="punctuation separator rust">,</span>
    <span class="meta path rust">sequence<span class="punctuation accessor rust">::</span></span>separated_pair<span class="punctuation separator rust">,</span>
    IResult<span class="punctuation separator rust">,</span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation terminator rust">;</span>

<span class="meta annotation rust"><span class="punctuation definition annotation rust">#</span><span class="punctuation section group begin rust">[</span><span class="variable annotation rust">derive</span><span class="meta annotation parameters rust"><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span></span><span class="meta annotation parameters rust"><span class="meta group rust">Debug<span class="punctuation separator rust">,</span> Eq<span class="punctuation separator rust">,</span> PartialEq</span></span><span class="meta annotation parameters rust"><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="punctuation section group end rust">]</span></span>
<span class="meta struct rust"><span class="storage type struct rust">struct</span> </span><span class="meta struct rust"><span class="entity name struct rust">Point</span> </span><span class="meta struct rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="variable other member rust">x</span><span class="punctuation separator rust">:</span> <span class="storage type rust">i32</span>,
    <span class="variable other member rust">y</span><span class="punctuation separator rust">:</span> <span class="storage type rust">i32</span>,
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>

<span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">parse_point</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span><span class="variable parameter rust">input</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> <span class="meta function return-type rust"><span class="punctuation separator rust">-&gt;</span> <span class="meta generic rust">IResult<span class="punctuation definition generic begin rust">&lt;</span><span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span>, Point<span class="punctuation definition generic end rust">&gt;</span></span></span> </span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> When you call a parser like `i32`, it will return a tuple of the
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> remaining input and the parsed value. If you unpack the `IResult` above,
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> you&#39;ll see `parse_point` also returns a tuple of the remaining input and
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> the parsed value
</span>    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> x</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="storage type rust">i32</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Because input is rebound to the remaining input in the line above, the
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> following line will parse and consume the comma. Since we don&#39;t care
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> about the comma, we use the `_` to ignore it
</span>    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> <span class="keyword operator rust">_</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="storage type rust">char</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted single rust"><span class="punctuation definition string begin rust">&#39;</span>,<span class="punctuation definition string end rust">&#39;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> And now input is only the y value
</span>    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> y</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="storage type rust">i32</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Finally, we construct our return value, and return it alongside the
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> remaining input
</span>    <span class="support type rust">Ok</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">,</span> y </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>

<span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">main</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> </span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="storage type rust">let</span> input <span class="keyword operator rust">=</span> <span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>123,456<span class="constant character escape rust">\n</span>789,1011<span class="punctuation definition string end rust">&quot;</span></span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Here we construct a parser that will parse a list of `Point`s separated
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> by `line_ending`.
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span>
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Note that the `separated_list0` takes parsers as arguments, so we don&#39;t
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> give `line_ending` or `parse_point` any arguments.
</span>    <span class="storage type rust">let</span> <span class="storage modifier rust">mut</span> parse_points <span class="keyword operator rust">=</span> <span class="support function rust">separated_list0</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>line_ending<span class="punctuation separator rust">,</span> parse_point</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> points</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="support function rust">parse_points</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">unwrap</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> `points` is now a `Vec&lt;Point&gt;` containing the two points we parsed
</span>    <span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>
        points<span class="punctuation separator rust">,</span>
        <span class="support macro rust">vec!</span><span class="meta group rust"><span class="punctuation section group begin rust">[</span>Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">123</span><span class="punctuation separator rust">,</span> y<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">456</span> </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation separator rust">,</span> Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">789</span><span class="punctuation separator rust">,</span> y<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">1011</span> </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation section group end rust">]</span></span>
    </span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> And the remaining input should now be empty
</span>    <span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> <span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span><span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>

    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Or setting up and using a parser in a single line:
</span>    <span class="storage type rust">let</span> input <span class="keyword operator rust">=</span> <span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span>34,56<span class="constant character escape rust">\n</span>21,98<span class="punctuation definition string end rust">&quot;</span></span><span class="punctuation terminator rust">;</span>
    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> points</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="support function rust">separated_list0</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>newline<span class="punctuation separator rust">,</span> parse_point_concise</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>.<span class="support function rust">unwrap</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
    <span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>points<span class="punctuation separator rust">,</span> <span class="support macro rust">vec!</span><span class="meta group rust"><span class="punctuation section group begin rust">[</span>Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">34</span><span class="punctuation separator rust">,</span> y<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">56</span> </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation separator rust">,</span> Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">21</span><span class="punctuation separator rust">,</span> y<span class="punctuation separator rust">:</span> <span class="constant numeric integer decimal rust">98</span> </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span><span class="punctuation section group end rust">]</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
    <span class="support macro rust">assert_eq!</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> <span class="string quoted double rust"><span class="punctuation definition string begin rust">&quot;</span><span class="punctuation definition string end rust">&quot;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation terminator rust">;</span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>

<span class="meta function rust"><span class="meta function rust"><span class="storage type function rust">fn</span> </span><span class="entity name function rust">parse_point_concise</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters begin rust">(</span><span class="variable parameter rust">input</span><span class="punctuation separator rust">:</span> <span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span></span><span class="meta function rust"><span class="meta function parameters rust"><span class="punctuation section parameters end rust">)</span></span></span></span><span class="meta function rust"> <span class="meta function return-type rust"><span class="punctuation separator rust">-&gt;</span> <span class="meta generic rust">IResult<span class="punctuation definition generic begin rust">&lt;</span><span class="keyword operator rust">&amp;</span><span class="storage type rust">str</span>, Point<span class="punctuation definition generic end rust">&gt;</span></span></span> </span><span class="meta function rust"><span class="meta block rust"><span class="punctuation section block begin rust">{</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> `separated_pair` is a combinator that takes three parsers, and returns a
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> parser that returns a tuple of the results of the first and third
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> parsers, using the second parser as a separator. This allows us to
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> rewrite `parse_point` as follows:
</span>    <span class="storage type rust">let</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> <span class="meta group rust"><span class="punctuation section group begin rust">(</span>x<span class="punctuation separator rust">,</span> y</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span> <span class="keyword operator rust">=</span> <span class="support function rust">separated_pair</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="storage type rust">i32</span><span class="punctuation separator rust">,</span> <span class="storage type rust">char</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="string quoted single rust"><span class="punctuation definition string begin rust">&#39;</span>,<span class="punctuation definition string end rust">&#39;</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="punctuation separator rust">,</span> <span class="storage type rust">i32</span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input</span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span><span class="keyword operator rust">?</span><span class="punctuation terminator rust">;</span>
    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> Then we construct our return value, and return it alongside the remaining
</span>    <span class="comment line double-slash rust"><span class="punctuation definition comment rust">//</span> input.
</span>    <span class="support type rust">Ok</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span><span class="meta group rust"><span class="punctuation section group begin rust">(</span>input<span class="punctuation separator rust">,</span> Point <span class="meta block rust"><span class="punctuation section block begin rust">{</span> x<span class="punctuation separator rust">,</span> y </span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span></span><span class="meta group rust"><span class="punctuation section group end rust">)</span></span>
</span><span class="meta block rust"><span class="punctuation section block end rust">}</span></span></span>
</span></code></pre>
<h2><a href="#basic-elements" aria-hidden="true" class="anchor" id="basic-elements"></a>Basic elements</h2>
<p>Those are used to recognize the lowest level elements of your grammar, like, &quot;here is a dot&quot;, &quot;here is a number&quot;, &quot;here is a line ending&quot;. These are split up into matching a single byte or character, and matching multiple bytes or characters.</p>
<h3><a href="#single-byte-or-character-parsers" aria-hidden="true" class="anchor" id="single-byte-or-character-parsers"></a>Single byte or character parsers</h3>
<p>All of these parsers will return a single byte or character.</p>
<table>
<thead>
<tr>
<th>parser</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.char.html">char</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.char.html">char</a></td>
<td><code>char('a')</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches one specific character</td>
</tr>
<tr>
<td></td>
<td><code>char('a')</code></td>
<td><code>&quot;cba&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Char</td>
<td>If that character isn't the immediate input, parsing fails</td>
</tr>
<tr>
<td></td>
<td><code>char('')</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>''</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Multi-byte characters work as well</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.anychar.html">anychar</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.anychar.html">anychar</a></td>
<td><code>anychar</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches any single character</td>
</tr>
<tr>
<td></td>
<td><code>anychar</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>''</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>Multi-byte characters work as well</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.one_of.html">one_of</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.one_of.html">one_of</a></td>
<td><code>one_of(&quot;abc&quot;)</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>'a'</code><br>Remainder: <code>&quot;bc&quot;</code></td>
<td>Matches one of the provided characters</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.none_of.html">none_of</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.none_of.html">none_of</a></td>
<td><code>none_of(&quot;abc&quot;)</code></td>
<td><code>&quot;xyab&quot;</code></td>
<td>Result: <code>'x'</code><br>Remainder: <code>&quot;yab&quot;</code></td>
<td>Matches a single character that is anything but the provided characters</td>
</tr>
</tbody>
</table>
<h3><a href="#sequence-of-bytes-or-characters-parsers" aria-hidden="true" class="anchor" id="sequence-of-bytes-or-characters-parsers"></a>Sequence of bytes or characters parsers</h3>
<p>These parsers will return a slice of bytes or characters. Those suffixed with <code>0</code> can return an empty slice if they match nothing. They usually have variants that are suffixed with <code>1</code> that will refuse to match unless there's at least 1 byte or character they can match. For instance, <code>digit0</code> will match an empty string, but <code>digit1</code> will not:</p>
<table>
<thead>
<tr>
<th>parser</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html">digit0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit0.html">digit0</a></td>
<td><code>digit0</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches zero or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html">digit1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit1.html">digit1</a></td>
<td><code>digit1</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches one or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td></td>
<td><code>digit0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;abc123&quot;</code></td>
<td>Because it is allowed to return an empty string, this does not error</td>
</tr>
<tr>
<td></td>
<td><code>digit1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Digit</td>
<td>This however does error, because there must be at least one numerical ASCII character</td>
</tr>
</tbody>
</table>
<p>This goes for all the <code>0</code> and <code>1</code> suffixed parsers below:</p>
<table>
<thead>
<tr>
<th>parser</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.is_a.html">is_a</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.is_a.html">is_a</a></td>
<td><code>is_a(&quot;ab&quot;)</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>&quot;abab&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Matches a sequence of any of the characters passed as arguments</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.is_not.html">is_not</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.is_not.html">is_not</a></td>
<td><code>is_not(&quot;cd&quot;)</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>&quot;abab&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Matches a sequence of none of the characters passed as arguments</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha0.html">alpha0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alpha0.html">alpha0</a></td>
<td><code>alpha0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Matches zero or more alphabetical ASCII characters (<code>a-zA-Z</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alpha1.html">alpha1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alpha1.html">alpha1</a></td>
<td><code>alpha1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Matches one or more alphabetical ASCII characters (<code>a-zA-Z</code>)</td>
</tr>
<tr>
<td></td>
<td><code>alpha1</code></td>
<td><code>&quot;&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Alpha</td>
<td>Only ASCII counts for these, not all of the unicode alphabetical characters. (These are Greek Alphas.)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit0.html">digit0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit0.html">digit0</a></td>
<td><code>digit0</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches zero or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.digit1.html">digit1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.digit1.html">digit1</a></td>
<td><code>digit1</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Matches one or more numerical ASCII characters (<code>0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric0.html">alphanumeric0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alphanumeric0.html">alphanumeric0</a></td>
<td><code>alphanumeric0</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc123&quot;</code><br>No remainder</td>
<td>Matches zero or more alphanumeric ASCII characters (<code>a-zA-Z0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.alphanumeric1.html">alphanumeric1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.alphanumeric1.html">alphanumeric1</a></td>
<td><code>alphanumeric1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc123&quot;</code><br>No remainder</td>
<td>Matches one or more alphanumeric ASCII characters (<code>a-zA-Z0-9</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit0.html">hex_digit0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.hex_digit0.html">hex_digit0</a></td>
<td><code>hex_digit0</code></td>
<td><code>&quot;123abcghi&quot;</code></td>
<td>Result: <code>&quot;123abc&quot;</code><br>Remainder: <code>&quot;ghi&quot;</code></td>
<td>Matches zero or more hexadecimal ASCII characters (<code>0-9a-fA-F</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.hex_digit1.html">hex_digit1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.hex_digit1.html">hex_digit1</a></td>
<td><code>hex_digit1</code></td>
<td><code>&quot;123abcghi&quot;</code></td>
<td>Result: <code>&quot;123abc&quot;</code><br>Remainder: <code>&quot;ghi&quot;</code></td>
<td>Matches one or more hexadecimal ASCII characters (<code>0-9a-fA-F</code>)</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag.html">tag</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.tag.html">tag</a><br>bits::complete::<a href="https://docs.rs/nom/latest/nom/bits/complete/fn.tag.html">tag</a><br>bits::streaming::<a href="https://docs.rs/nom/latest/nom/bits/streaming/fn.tag.html">tag</a></td>
<td><code>tag(&quot;hello&quot;)</code></td>
<td><code>&quot;hello world&quot;</code></td>
<td>Result: <code>&quot;hello&quot;</code><br>Remainder: <code>&quot;world&quot;</code></td>
<td>Recognizes a specific suite of characters, bytes, or bits</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.tag_no_case.html">tag_no_case</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.tag_no_case.html">tag_no_case</a></td>
<td><code>tag_no_case(&quot;hello&quot;)</code></td>
<td><code>&quot;HeLLo World&quot;</code></td>
<td>Result: <code>&quot;HeLLo&quot;</code><br>Remainder: <code>&quot;World&quot;</code></td>
<td>Recognizes a specific suite of characters, in a case insensitive manner</td>
</tr>
<tr>
<td></td>
<td><code>tag_no_case(&quot;&quot;)</code></td>
<td><code>&quot; &quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>This also works with non-ASCII characters. A <code></code> is a lowercase <code></code>. (Greek Gamma)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.newline.html">newline</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.newline.html">newline</a></td>
<td><code>newline</code></td>
<td><code>&quot;\nhello&quot;</code></td>
<td>Result: <code>'\n'</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches a newline character, also known as line feed, <code>\n</code>, or <code>LF</code></td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.crlf.html">crlf</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.crlf.html">crlf</a></td>
<td><code>crlf</code></td>
<td><code>&quot;\r\nhello&quot;</code></td>
<td>Result: <code>&quot;\r\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches a carriage return followed by a newline, also known as <code>\r\n</code> or <code>CRLF</code></td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.line_ending.html">line_ending</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.line_ending.html">line_ending</a></td>
<td><code>line_ending</code></td>
<td><code>&quot;\r\nhello&quot;</code></td>
<td>Result: <code>&quot;\r\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches an end of line, either Unix style (<code>\n</code>/<code>LF</code>) or Windows style (<code>\r\n</code>/<code>CRLF</code>)</td>
</tr>
<tr>
<td></td>
<td><code>line_ending</code></td>
<td><code>&quot;\nhello&quot;</code></td>
<td>Result: <code>&quot;\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Basically <code>line_ending</code> is the same as <a href="alt"><code>alt((crlf, newline))</code></a>, but has a better performance</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.space0.html">space0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.space0.html">space0</a></td>
<td><code>space0</code></td>
<td><code>&quot; \t\nhello&quot;</code></td>
<td>Result: <code>&quot; \t&quot;</code><br>Remainder: <code>&quot;\nhello&quot;</code></td>
<td>Matches zero or more spaces (<code>' '</code>) and tabs (<code>\t</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.space1.html">space1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.space1.html">space1</a></td>
<td><code>space1</code></td>
<td><code>&quot; \t\nhello&quot;</code></td>
<td>Result: <code>&quot; \t&quot;</code><br>Remainder: <code>&quot;\nhello&quot;</code></td>
<td>Matches one or more spaces (<code>' '</code>) and tabs (<code>\t</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace0.html">multispace0</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.multispace0.html">multispace0</a></td>
<td><code>multispace0</code></td>
<td><code>&quot; \t\nhello&quot;</code></td>
<td>Result: <code>&quot; \t\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches zero or more spaces (<code>' '</code>), tabs (<code>\t</code>), line feeds (<code>\n</code>), and carriage returns (<code>\r</code>)</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.multispace1.html">multispace1</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.multispace1.html">multispace1</a></td>
<td><code>multispace1</code></td>
<td><code>&quot; \t\nhello&quot;</code></td>
<td>Result: <code>&quot; \t\n&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>Matches one or more spaces (<code>' '</code>), tabs (<code>\t</code>), line feeds (<code>\n</code>), and carriage returns (<code>\r</code>)</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take.html">take</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take.html">take</a><br>bits::complete::<a href="https://docs.rs/nom/latest/nom/bits/complete/fn.take.html">take</a><br>bits::streaming::<a href="https://docs.rs/nom/latest/nom/bits/streaming/fn.take.html">take</a></td>
<td><code>take(4_u8)</code></td>
<td><code>&quot;hello&quot;</code></td>
<td>Result: <code>&quot;hell&quot;</code><br>Remainder: <code>&quot;o&quot;</code></td>
<td>Takes a specific number of characters, bytes, or bits</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while.html">take_while</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while.html">take_while</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while1.html">take_while1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while1.html">take_while1</a></td>
<td><code>take_while(|c| c as u32 &gt; 64)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns the longest consecutive list of bytes or characters for which the provided function returns true. <code>take_while1</code> does the same, but must return at least one character</td>
</tr>
<tr>
<td></td>
<td><code>take_while(|c| c &lt; 0x7f)</code></td>
<td><code>&amp;[0x01, 0x02, 0x03, 0xf0, 0x9f, 0x92, 0x9e]</code></td>
<td>Result: <code>[1, 2, 3]</code><br>Remainder: <code>&amp;[0xf0, 0x9f, 0x92, 0x9e]</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>take_while(|c| c as u32 &gt; 64)</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>No remainder</td>
<td>Be careful with casting <code>char</code> to <code>u8</code>. Casting to <code>u32</code> works as expected</td>
</tr>
<tr>
<td></td>
<td><code>take_while(|c| c as u8 &gt; 64)</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>Remainder: <code>&quot;&quot;</code></td>
<td>But casting to <code>u8</code> is lossy</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_while_m_n.html">take_while_m_n</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_while_m_n.html">take_while_m_n</a></td>
<td><code>take_while_m_n(4, 5, |c: char| c.is_ascii_alphanumeric())</code></td>
<td><code>&quot;abcd123&quot;</code></td>
<td>Result: <code>&quot;abcd1&quot;</code><br>Remainder: <code>&quot;23&quot;</code></td>
<td>Like <code>take_while</code>, but with a minimum and maximum length for the match</td>
</tr>
<tr>
<td></td>
<td><code>take_while_m_n(4, 5, |c: char| c.is_ascii_alphanumeric())</code></td>
<td><code>&quot;abcd-123&quot;</code></td>
<td>Result: <code>&quot;abcd&quot;</code><br>Remainder: <code>&quot;-123&quot;</code></td>
<td>In the example above, parsing stops because the upper limit is reached. In this one, the predicate stops being true</td>
</tr>
<tr>
<td></td>
<td><code>take_while_m_n(4, 5, |c: char| c.is_ascii_alphanumeric())</code></td>
<td><code>&quot;abc-123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: TakeWhileMN</td>
<td>And here the lower limit isn't reached yet when the predicate stops being true</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_till.html">take_till</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_till.html">take_till</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_till1.html">take_till1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_till1.html">take_till1</a></td>
<td><code>take_till(|c| c as u32 &lt;= 64)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns the longest list of consecutive bytes or characters for which the provided function returns false. <code>take_till1</code> does the same, but must return at least one character. Basically <code>take_till</code> is the same as <code>take_while</code> but with the result of the provided function negated</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until.html">take_until</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_until.html">take_until</a><br>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.take_until1.html">take_until1</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.take_until1.html">take_until1</a></td>
<td><code>take_until(&quot;world&quot;)</code></td>
<td><code>&quot;Hello world&quot;</code></td>
<td>Result: <code>&quot;Hello &quot;</code><br>Remainder: <code>&quot;world&quot;</code></td>
<td>Returns the longest list of bytes or characters until the provided tag is found. <code>take_until1</code> does the same, but must return at least one character</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.escaped.html">escaped</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.escaped.html">escaped</a></td>
<td><code>escaped(digit1, '\\', one_of(r#&quot;&quot;n\&quot;#))</code></td>
<td><code>r#&quot;12\&quot;34&quot;#</code></td>
<td>Result: <code>&quot;12\\\&quot;34&quot;</code><br>No remainder</td>
<td>Matches a string with escaped characters. The first parser is for regular characters, the second is the control (escape) character, and the third is for the escaped characters. Note that the string is delimited with <code>r#&quot;</code> and <code>&quot;#</code>, so the backslash is in the string.</td>
</tr>
<tr>
<td></td>
<td><code>escaped(digit1, '\\', one_of(r#&quot;&quot;n\&quot;#))</code></td>
<td><code>r#&quot;12&quot;34&quot;#</code></td>
<td>Result: <code>&quot;12&quot;</code><br>Remainder: <code>&quot;\&quot;34&quot;</code></td>
<td>Note how the <code>&quot;</code> between <code>2</code> and <code>3</code> is not preceded by a <code>\</code> here, and thus parsing ends here</td>
</tr>
<tr>
<td></td>
<td><code>delimited(char('@'), escaped(is_not(&quot;@;&quot;), ';', one_of(&quot;@;&quot;)), char('@'))</code></td>
<td><code>&quot;@hello;@world;;@&quot;</code></td>
<td>Result: <code>&quot;hello;@world;;&quot;</code><br>No remainder</td>
<td>This is a good example of why <code>escaped</code> is useful. First of all, the value we're looking for is delimited at start and end by a <code>@</code>. But it also contains a <code>@</code> which is escaped by a <code>;</code>. So the normal characters parser says &quot;anything except <code>@</code> and <code>;</code>.&quot; The parsing doesn't stop at the escaped <code>@</code> because it's escaped with the <code>;</code>, and allowed by the third parser. Likewise the <code>;;</code> at the end is allowed as well</td>
</tr>
<tr>
<td></td>
<td><code>delimited(char('&quot;'), escaped(is_not(r#&quot;&quot;\&quot;#), '\\', one_of(r#&quot;&quot;\&quot;#)), char('&quot;'))</code></td>
<td><code>r#&quot;&quot;hello\&quot;world\\&quot;&quot;#</code></td>
<td>Result: <code>&quot;hello\\\&quot;world\\\\&quot;</code><br>No remainder</td>
<td>This is identical to the previous example, except we use <code>\</code> as the control character, and <code>&quot;</code> as the delimiter. It is just a lot harder to read because of the escaping we have to do to get Rust to grok our strings</td>
</tr>
<tr>
<td></td>
<td><code>delimited(char('&quot;'), escaped(is_not(&quot;\&quot;\\&quot;), '\\', one_of(&quot;\&quot;\\&quot;)), char('&quot;'))</code></td>
<td><code>&quot;\&quot;hello\\\&quot;world\\\\\&quot;&quot;</code></td>
<td>Result: <code>&quot;hello\\\&quot;world\\\\&quot;</code><br>No remainder</td>
<td>And again, the same as previous but with different notation</td>
</tr>
<tr>
<td></td>
<td><code>escaped(digit1, '\\', tag(&quot;boop&quot;))</code></td>
<td><code>r&quot;12\boop34boo&quot;</code></td>
<td>Result: <code>&quot;12\\boop34&quot;</code><br>Remainder: <code>&quot;boo&quot;</code></td>
<td>The escaped parser can actually be any parser, so here we're looking for the string <code>boop</code> instead of just a single character</td>
</tr>
<tr>
<td>bytes::complete::<a href="https://docs.rs/nom/latest/nom/bytes/complete/fn.escaped_transform.html">escaped_transform</a><br>bytes::streaming::<a href="https://docs.rs/nom/latest/nom/bytes/streaming/fn.escaped_transform.html">escaped_transform</a></td>
<td><code>escaped_transform(alpha1, '\\', value(&quot;n&quot;, char('n')))</code></td>
<td><code>r&quot;ab\ncd&quot;</code></td>
<td>Result: <code>&quot;abncd&quot;</code><br>No remainder</td>
<td>Similar to <code>escaped</code>, but the third parser can return a different value into which the control character and escaped character are transformed. <a href="#general-combinators"><code>value</code></a> is very useful for this, but you can use your own parsers as well</td>
</tr>
<tr>
<td></td>
<td><code>escaped_transform(alpha1, '\\', value(&quot;BOO&quot;, char('n')))</code></td>
<td><code>r&quot;ab\ncd&quot;</code></td>
<td>Result: <code>&quot;abBOOcd&quot;</code><br>No remainder</td>
<td>Above <code>\n</code> is transformed into just <code>n</code>, but here that combo is transformed into <code>BOO</code></td>
</tr>
<tr>
<td></td>
<td><code>escaped_transform(alpha1, '\\', alt((value(&quot;BOO&quot;, char('n')), value(&quot;EEK&quot;, char('c')))))</code></td>
<td><code>r&quot;ab\ncd\cef&quot;</code></td>
<td>Result: <code>&quot;abBOOcdEEKef&quot;</code><br>No remainder</td>
<td><a href="#choice-combinators"><code>alt</code></a> is useful to transform multiple different escape sequences into different values. In addition to <code>\n</code> into <code>BOO</code>, <code>\c</code> is converted into <code>EEK</code></td>
</tr>
</tbody>
</table>
<h3><a href="#numbers" aria-hidden="true" class="anchor" id="numbers"></a>Numbers</h3>
<p>Nom can parse numbers either in <a href="#text-to-number">text</a> or <a href="#binary-to-number">binary</a> formats.</p>
<h4><a href="#text-to-number" aria-hidden="true" class="anchor" id="text-to-number"></a>Text to number</h4>
<table>
<thead>
<tr>
<th>parser</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.i8.html">i8</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.i8.html">i8</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.i16.html">i16</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.i16.html">i16</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.i32.html">i32</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.i32.html">i32</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.i64.html">i64</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.i64.html">i64</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.i128.html">i128</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.i128.html">i128</a></td>
<td><code>i8</code></td>
<td><code>&quot;123&quot;</code></td>
<td>Result: <code>123</code><br>No remainder</td>
<td>Recognizes a signed integer. Various bitsize functions are available</td>
</tr>
<tr>
<td></td>
<td><code>i8</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>As always, remaining characters are ignored</td>
</tr>
<tr>
<td></td>
<td><code>i8</code></td>
<td><code>&quot;+123&quot;</code></td>
<td>Result: <code>123</code><br>No remainder</td>
<td>You can use a sign if you want to</td>
</tr>
<tr>
<td></td>
<td><code>i8</code></td>
<td><code>&quot;-123&quot;</code></td>
<td>Result: <code>-123</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>i8</code></td>
<td><code>&quot;-200&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Digit</td>
<td>If the digits make a number that's too large, you will get an error</td>
</tr>
<tr>
<td>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.u8.html">u8</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.u8.html">u8</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.u16.html">u16</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.u16.html">u16</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.u32.html">u32</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.u32.html">u32</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.u64.html">u64</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.u64.html">u64</a><br>character::complete::<a href="https://docs.rs/nom/latest/nom/character/complete/fn.u128.html">u128</a><br>character::streaming::<a href="https://docs.rs/nom/latest/nom/character/streaming/fn.u128.html">u128</a></td>
<td><code>u8</code></td>
<td><code>&quot;123&quot;</code></td>
<td>Result: <code>123</code><br>No remainder</td>
<td>Recognizes an unsigned integer. Various bitsize functions are available</td>
</tr>
<tr>
<td></td>
<td><code>u8</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>u8</code></td>
<td><code>&quot;+123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Digit</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>u8</code></td>
<td><code>&quot;-123&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Digit</td>
<td></td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.double.html">double</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.double.html">double</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.float.html">float</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.float.html">float</a></td>
<td><code>double</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>1.23</code><br>No remainder</td>
<td><code>double</code> recognizes floating point number in text format and returns an <code>f64</code>.  <code>float</code> does the same for <code>f32</code></td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td><code>&quot;123.456&quot;</code></td>
<td>Result: <code>123.456</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td><code>&quot;123.456E-02&quot;</code></td>
<td>Result: <code>1.23456</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td><code>&quot;123.456E+02&quot;</code></td>
<td>Result: <code>12345.6</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td><code>&quot;123.456hello&quot;</code></td>
<td>Result: <code>123.456</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>double</code></td>
<td><code>&quot;123.456e0hi&quot;</code></td>
<td>Result: <code>123.456</code><br>Remainder: <code>&quot;hi&quot;</code></td>
<td></td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.recognize_float.html">recognize_float</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.recognize_float.html">recognize_float</a></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>&quot;123E-02&quot;</code><br>No remainder</td>
<td>Recognizes floating point number in text format and returns the corresponding slice (there is no <code>recognize_double</code> as there is no difference in the text form of float vs double)</td>
</tr>
<tr>
<td></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123.456&quot;</code></td>
<td>Result: <code>&quot;123.456&quot;</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123.456E-02&quot;</code></td>
<td>Result: <code>&quot;123.456E-02&quot;</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123.456E+02&quot;</code></td>
<td>Result: <code>&quot;123.456E+02&quot;</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123.456hello&quot;</code></td>
<td>Result: <code>&quot;123.456&quot;</code><br>Remainder: <code>&quot;hello&quot;</code></td>
<td>As always, remaining characters are ignored</td>
</tr>
<tr>
<td></td>
<td><code>recognize_float</code></td>
<td><code>&quot;123.456e0hi&quot;</code></td>
<td>Result: <code>&quot;123.456e0&quot;</code><br>Remainder: <code>&quot;hi&quot;</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>recognize(float)</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>&quot;123E-02&quot;</code><br>No remainder</td>
<td><code>recognize_float</code> is basically a slightly more optimal version of <code>recognize(double)</code> or <code>recognize(float)</code></td>
</tr>
<tr>
<td></td>
<td><code>recognize(double)</code></td>
<td><code>&quot;123E-02&quot;</code></td>
<td>Result: <code>&quot;123E-02&quot;</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.hex_u32.html">hex_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.hex_u32.html">hex_u32</a></td>
<td><code>hex_u32</code></td>
<td><code>b&quot;abcxyz&quot;</code></td>
<td>Result: <code>2748</code><br>Remainder: <code>&amp;[0x78, 0x79, 0x7a]</code></td>
<td>Recognizes hex-encoded <code>u32</code>. This only works with <code>&amp;[u8]</code> inputs</td>
</tr>
<tr>
<td></td>
<td><code>hex_u32</code></td>
<td><code>&amp;[0x61, 0x62, 0x63, 0x78, 0x79, 0x7a]</code></td>
<td>Result: <code>2748</code><br>Remainder: <code>&amp;[0x78, 0x79, 0x7a]</code></td>
<td>But for some reason, we're doing character recognition (this is the same as the <code>b&quot;abcxyz&quot;</code> above)</td>
</tr>
</tbody>
</table>
<h4><a href="#binary-to-number" aria-hidden="true" class="anchor" id="binary-to-number"></a>Binary to number</h4>
<table>
<thead>
<tr>
<th>parser</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i8.html">i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i8.html">i8</a></td>
<td><code>i8</code></td>
<td><code>&amp;[0xf0]</code></td>
<td>Result: <code>-16</code><br>No remainder</td>
<td>Recognizes a signed integer. Endianness does not matter for single byte numbers, so there's no <code>Endianness</code> parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u8.html">u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u8.html">u8</a></td>
<td><code>u8</code></td>
<td><code>&amp;[0xf0]</code></td>
<td>Result: <code>240</code><br>No remainder</td>
<td>Recognizes a unsigned integer. Endianness does not matter for single byte numbers, so there's no <code>Endianness</code> parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i16.html">i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i16.html">i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i24.html">i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i24.html">i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i32.html">i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i32.html">i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i64.html">i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i64.html">i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.i128.html">i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.i128.html">i128</a></td>
<td><code>i16(Endianness::Big)</code></td>
<td><code>&amp;[0xff, 0x00]</code></td>
<td>Result: <code>-256</code><br>No remainder</td>
<td>Recognizes a signed integer. Various bitsize functions are available. Endianness handled according to parameter</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u16.html">u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u16.html">u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u24.html">u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u24.html">u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u32.html">u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u32.html">u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u64.html">u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u64.html">u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.u128.html">u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.u128.html">u128</a></td>
<td><code>u16(Endianness::Big)</code></td>
<td><code>&amp;[0xff, 0x00]</code></td>
<td>Result: <code>65280</code><br>No remainder</td>
<td>Recognizes a unsigned integer. Various bitsize functions are available. Endianness handled according to parameter</td>
</tr>
<tr>
<td>number::<a href="https://docs.rs/nom/latest/nom/number/enum.Endianness.html">Endianness</a></td>
<td><code>u16(Endianness::Little)</code></td>
<td><code>&amp;[0xff, 0x00]</code></td>
<td>Result: <code>255</code><br>No remainder</td>
<td>Endianness can be <code>Big</code>, <code>Little</code>, or <code>Native</code></td>
</tr>
<tr>
<td></td>
<td><code>u16(Endianness::Native)</code></td>
<td><code>&amp;[0xff, 0x00]</code></td>
<td>Result: <code>255</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i8.html">be_i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i8.html">be_i8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i16.html">be_i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i16.html">be_i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i24.html">be_i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i24.html">be_i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i32.html">be_i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i32.html">be_i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i64.html">be_i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i64.html">be_i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_i128.html">be_i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_i128.html">be_i128</a></td>
<td><code>be_i16</code></td>
<td><code>&amp;[0xff, 0xaa]</code></td>
<td>Result: <code>-86</code><br>No remainder</td>
<td>Recognizes a big endian signed integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u8.html">be_u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u8.html">be_u8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u16.html">be_u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u16.html">be_u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u24.html">be_u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u24.html">be_u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u32.html">be_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u32.html">be_u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u64.html">be_u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u64.html">be_u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_u128.html">be_u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_u128.html">be_u128</a></td>
<td><code>be_u16</code></td>
<td><code>&amp;[0xff, 0xaa]</code></td>
<td>Result: <code>65450</code><br>No remainder</td>
<td>Recognizes a big endian unsigned integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i8.html">le_i8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i8.html">le_i8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i16.html">le_i16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i16.html">le_i16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i24.html">le_i24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i24.html">le_i24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i32.html">le_i32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i32.html">le_i32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i64.html">le_i64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i64.html">le_i64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_i128.html">le_i128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_i128.html">le_i128</a></td>
<td><code>le_i16</code></td>
<td><code>&amp;[0xff, 0xaa]</code></td>
<td>Result: <code>-21761</code><br>No remainder</td>
<td>Recognizes a big endian signed integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u8.html">le_u8</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u8.html">le_u8</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u16.html">le_u16</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u16.html">le_u16</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u24.html">le_u24</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u24.html">le_u24</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u32.html">le_u32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u32.html">le_u32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u64.html">le_u64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u64.html">le_u64</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_u128.html">le_u128</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_u128.html">le_u128</a></td>
<td><code>le_u16</code></td>
<td><code>&amp;[0xff, 0xaa]</code></td>
<td>Result: <code>43775</code><br>No remainder</td>
<td>Recognizes a big endian unsigned integer</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_f32.html">be_f32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_f32.html">be_f32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.be_f64.html">be_f64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.be_f64.html">be_f64</a></td>
<td><code>be_f32</code></td>
<td><code>&amp;[0x41, 0x48, 0x00, 0x00]</code></td>
<td>Result: <code>12.5</code><br>No remainder</td>
<td>Recognizes a big endian floating point number</td>
</tr>
<tr>
<td>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_f32.html">le_f32</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_f32.html">le_f32</a><br>number::complete::<a href="https://docs.rs/nom/latest/nom/number/complete/fn.le_f64.html">le_f64</a><br>number::streaming::<a href="https://docs.rs/nom/latest/nom/number/streaming/fn.le_f64.html">le_f64</a></td>
<td><code>le_f32</code></td>
<td><code>&amp;[0x00, 0x00, 0x48, 0x41]</code></td>
<td>Result: <code>12.5</code><br>No remainder</td>
<td>Recognizes a big endian floating point number</td>
</tr>
<tr>
<td></td>
<td><code>le_f32</code></td>
<td><code>&amp;[0x00, 0x00, 0x48, 0x41, 0x06, 0x09]</code></td>
<td>Result: <code>12.5</code><br>Remainder: <code>&amp;[0x06, 0x09]</code></td>
<td>All of these parsers only ever consume the exact number of bytes of their corresponding type</td>
</tr>
</tbody>
</table>
<h2><a href="#general-combinators" aria-hidden="true" class="anchor" id="general-combinators"></a>General combinators</h2>
<p>A combinator is a function that takes one or more parsers as arguments and returns a new parser. This allows you to combine parsers in various ways to create more complex parsers.</p>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.value.html">value</a></td>
<td><code>value(1234, alpha1)</code></td>
<td><code>&quot;abc789def&quot;</code></td>
<td>Result: <code>1234</code><br>Remainder: <code>&quot;789def&quot;</code></td>
<td>Returns the provided value if the parser succeeds</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map.html">map</a></td>
<td><code>map(digit1, |s: &amp;str| s.parse::&lt;u8&gt;().unwrap())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Maps a function on the result of a parser</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_opt.html">map_opt</a></td>
<td><code>map_opt(digit1, |s: &amp;str| s.parse::&lt;u8&gt;().ok())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Same as <code>map()</code> but requires the function to return an <code>Option</code></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_res.html">map_res</a></td>
<td><code>map_res(digit1, |s: &amp;str| s.parse::&lt;u8&gt;())</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>123</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Same as <code>map()</code> but requires the function to return an <code>Result</code></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.flat_map.html">flat_map</a></td>
<td><code>flat_map(u8, take)</code></td>
<td><code>&amp;[2, 90, 91, 92, 93]</code></td>
<td>Result: <code>[90, 91]</code><br>Remainder: <code>&amp;[0x5c, 0x5d]</code></td>
<td>Apply the first parser, then use its output as the argument for the second parser and apply that to the rest of the input. In this example <code>u8</code> reads a single byte as an unsigned integer, then makes that the argument to <code>take</code> causing it to read the next 2 bytes</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.map_parser.html">map_parser</a></td>
<td><code>map_parser(take(5u8), digit1)</code></td>
<td><code>&quot;123abc&quot;</code></td>
<td>Result: <code>&quot;123&quot;</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Apply the second parser on the result of the first parser</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.not.html">not</a></td>
<td><code>not(alpha1)</code></td>
<td><code>&quot;123&quot;</code></td>
<td>Result: <code>()</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Succeeds if the child parser returns an error</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.opt.html">opt</a></td>
<td><code>opt(alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>Some(&quot;abc&quot;)</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Returns an <code>Option</code> of the child parser. <code>Some()</code> if the child parser is succesful, and <code>None</code> if not</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.peek.html">peek</a></td>
<td><code>peek(alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;abc123&quot;</code></td>
<td>Applies the child parser but does not consume the input</td>
</tr>
<tr>
<td></td>
<td><code>alpha1</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.recognize.html">recognize</a></td>
<td><code>recognize(separated_pair(alpha1, char(','), alpha1))</code></td>
<td><code>&quot;abc,def&quot;</code></td>
<td>Result: <code>&quot;abc,def&quot;</code><br>No remainder</td>
<td>Returns a slice of the input consumed by the child parser/combinator. No matter how complex/nested, or whether combinators throw parts away, this will return a single slice with everything that was consumed</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.rest.html">rest</a></td>
<td><code>rest</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>&quot;abc&quot;</code><br>No remainder</td>
<td>Returns the remaining input. Mainly useful for combining with other combinators</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.rest_len.html">rest_len</a></td>
<td><code>rest_len</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>3</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Returns the length of the remaining input, does not consume anything</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.into.html">into</a></td>
<td><code>let output: IResult&lt;&amp;str, Vec&lt;u8&gt;&gt; = into(my_alpha1)</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Result: <code>[97, 98, 99, 100]</code><br>No remainder</td>
<td>Use Rust's <code>Into</code> trait to convert the result of a parser if possible</td>
</tr>
</tbody>
</table>
<h2><a href="#choice-combinators" aria-hidden="true" class="anchor" id="choice-combinators"></a>Choice combinators</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>branch::<a href="https://docs.rs/nom/latest/nom/branch/fn.alt.html">alt</a></td>
<td><code>alt((tag(&quot;ab&quot;), tag(&quot;cd&quot;)))</code></td>
<td><code>&quot;cdef&quot;</code></td>
<td>Result: <code>&quot;cd&quot;</code><br>Remainder: <code>&quot;ef&quot;</code></td>
<td>Try a list of parsers and return the result of the first successful one</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.success.html">success</a></td>
<td><code>success(1)</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>1</code><br>Remainder: <code>&quot;abc&quot;</code></td>
<td>Always succeeds and returns the given value without consuming any input. Useful for giving <code>alt</code> a default</td>
</tr>
<tr>
<td></td>
<td><code>alt((value(-1, char('-')), value(1, char('+')), success(1)))</code></td>
<td><code>&quot;10&quot;</code></td>
<td>Result: <code>1</code><br>Remainder: <code>&quot;10&quot;</code></td>
<td></td>
</tr>
<tr>
<td>branch::<a href="https://docs.rs/nom/latest/nom/branch/fn.permutation.html">permutation</a></td>
<td><code>permutation((tag(&quot;ab&quot;), tag(&quot;cd&quot;), tag(&quot;12&quot;)))</code></td>
<td><code>&quot;cd12abc&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;cd&quot;, &quot;12&quot;)</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Succeeds when all its child parser have succeeded, whatever the order</td>
</tr>
<tr>
<td></td>
<td><code>permutation((tag(&quot;ab&quot;), tag(&quot;cd&quot;), tag(&quot;12&quot;)))</code></td>
<td><code>&quot;abcd12&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;cd&quot;, &quot;12&quot;)</code><br>No remainder</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>permutation((tag(&quot;ab&quot;), tag(&quot;cd&quot;), tag(&quot;12&quot;)))</code></td>
<td><code>&quot;12cd&quot;</code></td>
<td>Error<br>Byte offset: 4<br>Code: Tag</td>
<td>But <em>all</em> parsers need to succeed</td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.cond.html">cond</a></td>
<td><code>cond(true, alpha1)</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>Some(&quot;abc&quot;)</code><br>Remainder: <code>&quot;123&quot;</code></td>
<td>Return result from the parser if the first argument is true, otherwise return <code>None</code></td>
</tr>
</tbody>
</table>
<h2><a href="#sequence-combinators" aria-hidden="true" class="anchor" id="sequence-combinators"></a>Sequence combinators</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.delimited.html">delimited</a></td>
<td><code>delimited(char('('), take(2u8), char(')'))</code></td>
<td><code>&quot;(ab)cd&quot;</code></td>
<td>Result: <code>&quot;ab&quot;</code><br>Remainder: <code>&quot;cd&quot;</code></td>
<td>Returns only the second parser out of three</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.preceded.html">preceded</a></td>
<td><code>preceded(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>&quot;XY&quot;</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Returns only the second parser out of two</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.terminated.html">terminated</a></td>
<td><code>terminated(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>&quot;ab&quot;</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Returns only the result from the first parser out of two, discarding the other</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.pair.html">pair</a></td>
<td><code>pair(tag(&quot;ab&quot;), tag(&quot;XY&quot;))</code></td>
<td><code>&quot;abXYZ&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;XY&quot;)</code><br>Remainder: <code>&quot;Z&quot;</code></td>
<td>Applies two parsers, returns their results as a tuple</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.separated_pair.html">separated_pair</a></td>
<td><code>separated_pair(tag(&quot;hello&quot;), char(','), tag(&quot;world&quot;))</code></td>
<td><code>&quot;hello,world!&quot;</code></td>
<td>Result: <code>(&quot;hello&quot;, &quot;world&quot;)</code><br>Remainder: <code>&quot;!&quot;</code></td>
<td>Returns the results from the first and third parsers as a tuple, discarding the second</td>
</tr>
<tr>
<td>sequence::<a href="https://docs.rs/nom/latest/nom/sequence/fn.tuple.html">tuple</a></td>
<td><code>tuple((tag(&quot;ab&quot;), tag(&quot;XY&quot;), take(1u8)))</code></td>
<td><code>&quot;abXYZ!&quot;</code></td>
<td>Result: <code>(&quot;ab&quot;, &quot;XY&quot;, &quot;Z&quot;)</code><br>Remainder: <code>&quot;!&quot;</code></td>
<td>Chains parsers and assembles the sub results in a tuple. You can use as many child parsers as you can put elements in a tuple</td>
</tr>
</tbody>
</table>
<h2><a href="#applying-a-parser-multiple-times" aria-hidden="true" class="anchor" id="applying-a-parser-multiple-times"></a>Applying a parser multiple times</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.count.html">count</a></td>
<td><code>count(take(2u8), 3)</code></td>
<td><code>&quot;abcdefgh&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]</code><br>Remainder: <code>&quot;gh&quot;</code></td>
<td>Applies the child parser a specified number of times and returns the list of results in a <code>Vec</code></td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many0.html">many0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many1.html">many1</a></td>
<td><code>many0(tag(&quot;ab&quot;))</code></td>
<td><code>&quot;abababc&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Applies the parser 0 or more times and returns the list of results in a <code>Vec</code>. <code>many1</code> does the same operation but must return at least one element</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many_m_n.html">many_m_n</a></td>
<td><code>many_m_n(2, 2, tag(&quot;ab&quot;))</code></td>
<td><code>&quot;ababc&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;c&quot;</code></td>
<td>Applies the parser at least <code>m</code> and at most <code>n</code> times and returns the list of results in a <code>Vec</code></td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.many_till.html">many_till</a></td>
<td><code>many_till(tag(&quot;ab&quot;), tag(&quot;ef&quot;))</code></td>
<td><code>&quot;ababefg&quot;</code></td>
<td>Result: <code>([&quot;ab&quot;, &quot;ab&quot;], &quot;ef&quot;)</code><br>Remainder: <code>&quot;g&quot;</code></td>
<td>Applies the first parser until the second applies. Returns a tuple containing the list of results from the first in a <code>Vec</code> and the result of the second</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.separated_list0.html">separated_list0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.separated_list1.html">separated_list1</a></td>
<td><code>separated_list0(tag(&quot;,&quot;), tag(&quot;ab&quot;))</code></td>
<td><code>&quot;ab,ab,ab.&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;.&quot;</code></td>
<td>Using the first parser to match separators, returns a <code>Vec</code> of zero or more results from the second parser. <code>separated_list1</code> does the same operation but must return at least one element</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many0.html">fold_many0</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many1.html">fold_many1</a><br>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.fold_many_m_n.html">fold_many_m_n</a></td>
<td><code>fold_many0(take(1u8), Vec::new, |mut acc, item| { acc.push(item); acc })</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Result: <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code><br>No remainder</td>
<td>Applies the parser 0 or more times and folds the list of return values. The <code>fold_many1</code> version must apply the parser at least one time, and <code>fold_many_m_n</code> must apply the parser at least <code>m</code> and at most <code>n</code> times</td>
</tr>
<tr>
<td>multi::<a href="https://docs.rs/nom/latest/nom/multi/fn.length_count.html">length_count</a></td>
<td><code>length_count(number, tag(&quot;ab&quot;))</code></td>
<td><code>&quot;2ababab&quot;</code></td>
<td>Result: <code>[&quot;ab&quot;, &quot;ab&quot;]</code><br>Remainder: <code>&quot;ab&quot;</code></td>
<td>Gets a number from the first parser, then applies the second parser that many times. <code>number</code> is a custom defined parser along the lines of text to integer parsers below</td>
</tr>
</tbody>
</table>
<h2><a href="#combinators-to-do-with-completeness" aria-hidden="true" class="anchor" id="combinators-to-do-with-completeness"></a>Combinators to do with completeness</h2>
<table>
<thead>
<tr>
<th>combinator</th>
<th>usage</th>
<th>input</th>
<th>output</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.all_consuming.html">all_consuming</a></td>
<td><code>all_consuming(pair(alpha1, number))</code></td>
<td><code>&quot;abc123&quot;</code></td>
<td>Result: <code>(&quot;abc&quot;, 123)</code><br>No remainder</td>
<td>Returns what the child parser returned if, and only if, the input is exhausted. Otherwise returns an error</td>
</tr>
<tr>
<td></td>
<td><code>all_consuming(pair(alpha1, number))</code></td>
<td><code>&quot;abc123abc&quot;</code></td>
<td>Error<br>Byte offset: 6<br>Code: Eof</td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.complete.html">complete</a></td>
<td><code>complete(nom::bytes::streaming::take(5u8))</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Complete</td>
<td>Turns an <code>Incomplete</code> result from a streaming parser into an error. The example is the equivalent of <code>nom::bytes::complete::take(5u8)</code></td>
</tr>
<tr>
<td></td>
<td><code>nom::bytes::streaming::take(5u8)</code></td>
<td><code>&quot;abcd&quot;</code></td>
<td>Incomplete<br>Needed: unknown</td>
<td></td>
</tr>
<tr>
<td>combinator::<a href="https://docs.rs/nom/latest/nom/combinator/fn.eof.html">eof</a></td>
<td><code>eof</code></td>
<td><code>&quot;&quot;</code></td>
<td>Result: <code>&quot;&quot;</code><br>No remainder</td>
<td>Returns an error if the input is not exhausted, otherwise returns the input</td>
</tr>
<tr>
<td></td>
<td><code>eof</code></td>
<td><code>&quot;abc&quot;</code></td>
<td>Error<br>Byte offset: 0<br>Code: Eof</td>
<td></td>
</tr>
</tbody>
</table>
<h3><a href="#binary-to-number-1" aria-hidden="true" class="anchor" id="binary-to-number-1"></a>Binary to number</h3>
<h1><a href="#fin" aria-hidden="true" class="anchor" id="fin"></a>Fin</h1>
</article>
</body>
</html>
